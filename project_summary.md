# 20241116152556_create_table_unit.sql

```sql
-- Create the function for updating timestamps CREATE OR REPLACE FUNCTION fn_set_updated_at() RETURNS TRIGGER AS $$ BEGIN NEW.updated_at = TIMEZONE('utc'::text, NOW()); RETURN NEW; END; $$ LANGUAGE plpgsql; -- Create the unit table CREATE TABLE unit ( id INTEGER GENERATED BY DEFAULT AS IDENTITY NOT NULL PRIMARY KEY, code VARCHAR(50) NOT NULL UNIQUE, name TEXT NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Create index on commonly searched columns CREATE INDEX idx_unit_code ON unit(code); -- Add updated_at trigger CREATE TRIGGER set_updated_at BEFORE UPDATE ON unit FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241116153626_create_table_nature_of_work.sql

```sql
-- create table CREATE TABLE nature_of_work ( id INTEGER GENERATED BY DEFAULT AS IDENTITY NOT NULL PRIMARY KEY, type VARCHAR(100) NOT NULL UNIQUE, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Add updated_at trigger CREATE TRIGGER set_updated_at BEFORE UPDATE ON nature_of_work FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241116155829_create_table_office.sql

```sql
CREATE TABLE office ( id INTEGER GENERATED BY DEFAULT AS IDENTITY NOT NULL PRIMARY KEY, unit_id INTEGER NOT NULL REFERENCES unit(id), code VARCHAR(50) NOT NULL UNIQUE, name VARCHAR(200) NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Create index for foreign key CREATE INDEX idx_office_unit_id ON office(unit_id); -- Add updated_at trigger CREATE TRIGGER set_updated_at BEFORE UPDATE ON office FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241116160732_create_table_program.sql

```sql
CREATE TABLE program ( id INTEGER GENERATED BY DEFAULT AS IDENTITY NOT NULL PRIMARY KEY, unit_id INTEGER NOT NULL REFERENCES unit(id), office_id INTEGER NOT NULL REFERENCES office(id), name TEXT NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Create indexes for foreign keys CREATE INDEX idx_program_unit_id ON program(unit_id); CREATE INDEX idx_program_office_id ON program(office_id); -- Add updated_at trigger CREATE TRIGGER set_updated_at BEFORE UPDATE ON program FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241116161506_create_table_position.sql

```sql
CREATE TABLE position ( id INTEGER GENERATED BY DEFAULT AS IDENTITY NOT NULL PRIMARY KEY, nature_of_work_id INTEGER NOT NULL REFERENCES nature_of_work(id), name VARCHAR(100) NOT NULL UNIQUE, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Create index for foreign key CREATE INDEX idx_position_nature_of_work_id ON position(nature_of_work_id); -- Add updated_at trigger CREATE TRIGGER set_updated_at BEFORE UPDATE ON position FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241116161733_create_table_employee_status.sql

```sql
-- create table CREATE TABLE employee_status ( id INTEGER GENERATED BY DEFAULT AS IDENTITY NOT NULL PRIMARY KEY, type VARCHAR(100) NOT NULL UNIQUE, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Add updated_at trigger CREATE TRIGGER set_updated_at BEFORE UPDATE ON employee_status FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241116162523_create_table_profile.sql

```sql
-- Create a table for public profiles create table profiles ( id uuid references auth.users on delete cascade not null primary key, updated_at timestamp with time zone default timezone('utc'::text, now()), employee_id varchar(50) unique, email varchar(255) unique, first_name text, middle_name text, last_name text, avatar_url text, unit_id integer references unit(id), nature_of_work_id integer references nature_of_work(id), office_id integer references office(id), program_id integer references program(id), position_id integer references position(id), employee_status_id integer references employee_status(id), created_at timestamp with time zone default timezone('utc'::text, now()) ); -- Set up Row Level Security (RLS) alter table profiles enable row level security; create policy "Public profiles are viewable by everyone." on profiles for select using (true); create policy "Users can insert their own profile." on profiles for insert with check ((select auth.uid()) = id); create policy "Users can update own profile." on profiles for update using ((select auth.uid()) = id); -- Create function to handle new user signup with Google OAuth data create function public.handle_new_user() returns trigger language plpgsql security definer set search_path = public as $$ begin insert into public.profiles ( id, email, first_name, last_name, avatar_url ) values ( new.id, new.email, coalesce( new.raw_user_meta_data->>'first_name', new.raw_user_meta_data->>'given_name', split_part(new.raw_user_meta_data->>'full_name', ' ', 1), 'Anonymous' ), coalesce( new.raw_user_meta_data->>'last_name', new.raw_user_meta_data->>'family_name', array_to_string( array_remove( string_to_array(new.raw_user_meta_data->>'full_name', ' '), split_part(new.raw_user_meta_data->>'full_name', ' ', 1) ), ' ' ), 'User' ), coalesce( new.raw_user_meta_data->>'avatar_url', new.raw_user_meta_data->>'picture', new.raw_user_meta_data->>'avatar', null ) ); return new; exception when others then raise log 'Error in handle_new_user: %', SQLERRM; return new; -- Still return the user even if profile creation fails end; $$; -- Create trigger for new user signup create trigger on_auth_user_created after insert on auth.users for each row execute procedure public.handle_new_user(); -- Set up Storage! insert into storage.buckets (id, name, public) values ('avatars', 'avatars',true); -- Set up access controls for storage. -- See https://supabase.com/docs/guides/storage#policy-examples for more details. create policy "Avatar images are publicly accessible." on storage.objects for select using (bucket_id = 'avatars'); create policy "Anyone can upload an avatar." on storage.objects for insert with check (bucket_id = 'avatars'); -- Allow users to upload their own avatar create policy "Users can update their own avatar" on storage.objects for update to authenticated using ( bucket_id = 'avatars' and auth.uid()::text = (storage.foldername(name))[1] ); -- Add updated_at trigger CREATE TRIGGER set_updated_at BEFORE UPDATE ON profiles FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241122141115_add_cascade_on_delete.sql

```sql
-- First, drop existing foreign key constraints ALTER TABLE office DROP CONSTRAINT office_unit_id_fkey; ALTER TABLE program DROP CONSTRAINT program_unit_id_fkey; ALTER TABLE program DROP CONSTRAINT program_office_id_fkey; ALTER TABLE position DROP CONSTRAINT position_nature_of_work_id_fkey; -- Then add them back with ON DELETE CASCADE ALTER TABLE office ADD CONSTRAINT office_unit_id_fkey FOREIGN KEY (unit_id) REFERENCES unit(id) ON DELETE CASCADE; ALTER TABLE program ADD CONSTRAINT program_unit_id_fkey FOREIGN KEY (unit_id) REFERENCES unit(id) ON DELETE CASCADE; ALTER TABLE program ADD CONSTRAINT program_office_id_fkey FOREIGN KEY (office_id) REFERENCES office(id) ON DELETE CASCADE; ALTER TABLE position ADD CONSTRAINT position_nature_of_work_id_fkey FOREIGN KEY (nature_of_work_id) REFERENCES nature_of_work(id) ON DELETE CASCADE;
```

# 20241122170218_add_realtime_tables.sql

```sql
-- alter publication supabase_realtime -- add table unit, -- nature_of_work, -- office, -- program, -- position, -- employee_status, -- profiles;
```

# 20241127102744_scope_type.sql

```sql
-- Create scope type CREATE TYPE scope_type AS ENUM ('all', 'office','program', 'unit');
```

# 20241127115411_create_roles_table.sql

```sql
-- Roles table CREATE TABLE roles ( id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, name VARCHAR(100) NOT NULL UNIQUE, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL );
```

# 20241127120413_create_permissions_table.sql

```sql
-- Permissions table CREATE TABLE permissions ( id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, name VARCHAR(100) NOT NULL UNIQUE, description TEXT, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL );
```

# 20241127121741_create_role_permissions_table.sql

```sql
-- Role permissions mapping with scope CREATE TABLE role_permissions ( id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, role_id INTEGER REFERENCES roles(id) ON DELETE CASCADE, permission_id INTEGER REFERENCES permissions(id) ON DELETE CASCADE, scope scope_type NOT NULL DEFAULT 'unit', created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, UNIQUE(role_id, permission_id) );
```

# 20241127121931_create_user_roles_table.sql

```sql
-- User roles mapping (one role per user) CREATE TABLE user_roles ( id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE, role_id INTEGER NOT NULL REFERENCES roles(id) ON DELETE CASCADE, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, UNIQUE(user_id) );
```

# 20241127123124_create_auth_jwt_function.sql

```sql
-- Grant necessary permissions GRANT USAGE ON SCHEMA auth TO postgres, authenticated, anon; GRANT SELECT ON TABLE user_roles TO supabase_auth_admin; GRANT SELECT ON TABLE roles TO supabase_auth_admin; GRANT EXECUTE ON FUNCTION auth.jwt() TO postgres, authenticated, anon; -- Create the JWT function CREATE OR REPLACE FUNCTION auth.jwt() RETURNS jsonb LANGUAGE plpgsql SECURITY DEFINER SET search_path = auth, public AS $$ DECLARE result jsonb; BEGIN SELECT jsonb_build_object( 'role', roles.name, 'role_id', roles.id ) INTO result FROM user_roles JOIN roles ON user_roles.role_id = roles.id WHERE user_roles.user_id = auth.uid(); RETURN COALESCE(result, '{}'::jsonb); END; $$;
```

# 20241127123317_create_permission_check_function.sql

```sql
CREATE OR REPLACE FUNCTION check_permission( required_permission VARCHAR, target_office_id INTEGER DEFAULT NULL, target_unit_id INTEGER DEFAULT NULL, target_program_id INTEGER DEFAULT NULL ) RETURNS BOOLEAN AS $$ DECLARE user_permission_scope scope_type; user_assigned_office_id INTEGER; user_assigned_unit_id INTEGER; user_assigned_program_id INTEGER; permission_exists BOOLEAN; BEGIN -- Get user's scope and IDs SELECT role_permission.scope, profile.office_id, profile.unit_id, profile.program_id, EXISTS ( SELECT 1 FROM role_permissions role_permission_check JOIN permissions permission ON permission.id = role_permission_check.permission_id WHERE role_permission_check.role_id = (auth.jwt()->>'role_id')::integer AND permission.name = required_permission ) INTO user_permission_scope, user_assigned_office_id, user_assigned_unit_id, user_assigned_program_id, permission_exists FROM profiles profile JOIN user_roles user_role ON profile.id = user_role.user_id JOIN role_permissions role_permission ON user_role.role_id = role_permission.role_id JOIN permissions permission ON role_permission.permission_id = permission.id WHERE profile.id = auth.uid() AND permission.name = required_permission; -- No permission found IF NOT permission_exists THEN RETURN FALSE; END IF; -- Check scope access from highest (all) to lowest (unit) RETURN CASE -- All level (highest scope) WHEN user_permission_scope = 'all' THEN TRUE -- Program level WHEN user_permission_scope = 'program' THEN target_program_id IS NULL OR target_program_id = user_assigned_program_id -- Office level WHEN user_permission_scope = 'office' THEN target_office_id IS NULL OR target_office_id = user_assigned_office_id -- Unit level (lowest scope) WHEN user_permission_scope = 'unit' THEN target_unit_id IS NULL OR target_unit_id = user_assigned_unit_id -- Default case ELSE FALSE END; END; $$ LANGUAGE plpgsql SECURITY DEFINER;
```

# 20241127152010_create_user_role_view.sql

```sql
CREATE VIEW user_role_view AS SELECT user_roles.user_id, roles.name as role_name, roles.id as role_id FROM user_roles JOIN roles ON user_roles.role_id = roles.id; CREATE OR REPLACE FUNCTION get_user_role() RETURNS TABLE ( role_name VARCHAR, role_id INTEGER ) LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$ BEGIN RETURN QUERY SELECT roles.name, roles.id FROM user_roles JOIN roles ON user_roles.role_id = roles.id WHERE user_roles.user_id = auth.uid(); END; $$; -- Grant execute permission GRANT EXECUTE ON FUNCTION get_user_role() TO authenticated;
```

# 20241128090943_system_admin_create_insert_function.sql

```sql
-- Create function to check if user is system admin CREATE OR REPLACE FUNCTION is_system_admin() RETURNS BOOLEAN LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$ DECLARE user_role_name VARCHAR; BEGIN -- Get the role name from the JWT SELECT (auth.jwt()->>'role')::VARCHAR INTO user_role_name; -- Check if user has system_admin role RETURN user_role_name = 'system_admin'; END; $$; -- Grant execute permission GRANT EXECUTE ON FUNCTION is_system_admin() TO authenticated;
```

# 20241128091037_RLS_for_unit.sql

```sql
-- Apply RLS policies to each table ALTER TABLE unit ENABLE ROW LEVEL SECURITY; CREATE POLICY "Enable read access for all users on unit" ON unit FOR SELECT TO authenticated USING (true); CREATE POLICY "Enable insert for system admin on unit" ON unit FOR INSERT TO authenticated WITH CHECK (is_system_admin()); CREATE POLICY "Enable update for system admin on unit" ON unit FOR UPDATE TO authenticated USING (is_system_admin()) WITH CHECK (is_system_admin()); CREATE POLICY "Enable delete for system admin on unit" ON unit FOR DELETE TO authenticated USING (is_system_admin());
```

# 20241128091124_RLS_for_office.sql

```sql
ALTER TABLE office ENABLE ROW LEVEL SECURITY; -- Create policies for office table CREATE POLICY "Enable read access for all users on office" ON office FOR SELECT TO authenticated USING (true); CREATE POLICY "Enable insert for system admin on office" ON office FOR INSERT TO authenticated WITH CHECK (is_system_admin()); CREATE POLICY "Enable update for system admin on office" ON office FOR UPDATE TO authenticated USING (is_system_admin()) WITH CHECK (is_system_admin()); CREATE POLICY "Enable delete for system admin on office" ON office FOR DELETE TO authenticated USING (is_system_admin());
```

# 20241128091158_RLS_for_program.sql

```sql
ALTER TABLE program ENABLE ROW LEVEL SECURITY; -- Create policies for program table CREATE POLICY "Enable read access for all users on program" ON program FOR SELECT TO authenticated USING (true); CREATE POLICY "Enable insert for system admin on program" ON program FOR INSERT TO authenticated WITH CHECK (is_system_admin()); CREATE POLICY "Enable update for system admin on program" ON program FOR UPDATE TO authenticated USING (is_system_admin()) WITH CHECK (is_system_admin()); CREATE POLICY "Enable delete for system admin on program" ON program FOR DELETE TO authenticated USING (is_system_admin());
```

# 20241128091248_RLS_for_nature_of_work.sql

```sql
ALTER TABLE nature_of_work ENABLE ROW LEVEL SECURITY; -- Create policies for nature_of_work table CREATE POLICY "Enable read access for all users on nature_of_work" ON nature_of_work FOR SELECT TO authenticated USING (true); CREATE POLICY "Enable insert for system admin on nature_of_work" ON nature_of_work FOR INSERT TO authenticated WITH CHECK (is_system_admin()); CREATE POLICY "Enable update for system admin on nature_of_work" ON nature_of_work FOR UPDATE TO authenticated USING (is_system_admin()) WITH CHECK (is_system_admin()); CREATE POLICY "Enable delete for system admin on nature_of_work" ON nature_of_work FOR DELETE TO authenticated USING (is_system_admin());
```

# 20241128091505_RLS_for_position.sql

```sql
ALTER TABLE position ENABLE ROW LEVEL SECURITY; -- Create policies for position table CREATE POLICY "Enable read access for all users on position" ON position FOR SELECT TO authenticated USING (true); CREATE POLICY "Enable insert for system admin on position" ON position FOR INSERT TO authenticated WITH CHECK (is_system_admin()); CREATE POLICY "Enable update for system admin on position" ON position FOR UPDATE TO authenticated USING (is_system_admin()) WITH CHECK (is_system_admin()); CREATE POLICY "Enable delete for system admin on position" ON position FOR DELETE TO authenticated USING (is_system_admin());
```

# 20241128091542_RLS_for_employee_status.sql

```sql
ALTER TABLE employee_status ENABLE ROW LEVEL SECURITY; CREATE POLICY "Enable read access for all users on employee_status" ON employee_status FOR SELECT TO authenticated USING (true); CREATE POLICY "Enable insert for system admin on employee_status" ON employee_status FOR INSERT TO authenticated WITH CHECK (is_system_admin()); CREATE POLICY "Enable update for system admin on employee_status" ON employee_status FOR UPDATE TO authenticated USING (is_system_admin()) WITH CHECK (is_system_admin()); CREATE POLICY "Enable delete for system admin on employee_status" ON employee_status FOR DELETE TO authenticated USING (is_system_admin());
```

# 20241216163511_create_table_operational_plan.sql

```sql
CREATE TYPE op_status AS ENUM ('draft', 'submitted', 'reviewing', 'revision', 'approved'); -- Create operational_plan table CREATE TABLE operational_plan ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), status op_status DEFAULT 'draft' NOT NULL, creator_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL, unit_id INTEGER REFERENCES unit(id) ON DELETE CASCADE NOT NULL, office_id INTEGER REFERENCES office(id) ON DELETE CASCADE, program_id INTEGER REFERENCES program(id) ON DELETE CASCADE, title TEXT NOT NULL, implementing_unit TEXT NOT NULL, review_by VARCHAR(255) NOT NULL, reviewer_position VARCHAR(255) NOT NULL, approve_by VARCHAR(255) NOT NULL, approver_position VARCHAR(255) NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Create indexes for foreign keys and commonly searched fields CREATE INDEX idx_operational_plan_unit_id ON operational_plan(unit_id); CREATE INDEX idx_operational_plan_office_id ON operational_plan(office_id); CREATE INDEX idx_operational_plan_program_id ON operational_plan(program_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON operational_plan FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241218095055_create_op_header_table.sql

```sql
-- Create op_header table CREATE TABLE op_header ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), operational_plan_id UUID REFERENCES operational_plan(id) ON DELETE CASCADE NOT NULL, position INTEGER NOT NULL, title TEXT NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Add indexes for better query performance CREATE INDEX idx_op_header_operational_plan_id ON op_header(operational_plan_id); CREATE INDEX idx_op_header_position ON op_header(position, operational_plan_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON op_header FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241218095410_create_op_annual_plan.sql

```sql
-- Create annual_plan table CREATE TABLE op_annual_plan ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), op_header_id UUID REFERENCES op_header(id) ON DELETE CASCADE NOT NULL, description TEXT NOT NULL, position INTEGER NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Add indexes for better query performance CREATE INDEX idx_op_annual_plan_op_header_id ON op_annual_plan(op_header_id); CREATE INDEX idx_op_annual_plan_position ON op_annual_plan(position, op_header_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON op_annual_plan FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241221025054_create_op_activities_table.sql

```sql
-- First create the activity table CREATE TABLE op_activity ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), op_annual_plan_id UUID REFERENCES op_annual_plan(id) ON DELETE CASCADE NOT NULL, activity TEXT NOT NULL, position INTEGER NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Then add indexes after table exists CREATE INDEX idx_op_activity_annual_plan_id ON op_activity(op_annual_plan_id); CREATE INDEX idx_op_activity_position ON op_activity(position, op_annual_plan_id); -- Finally add the trigger CREATE TRIGGER set_updated_at BEFORE UPDATE ON op_activity FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241221025055_create_op_indicator.sql

```sql
-- Create input type enum for indicators CREATE TYPE input_type_op AS ENUM ('percentage', 'number', 'ratio', 'text'); -- Create the indicator table CREATE TABLE op_activity_indicator ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), op_activity_id UUID REFERENCES op_activity(id) ON DELETE CASCADE NOT NULL, input_type input_type_op NOT NULL DEFAULT 'text', performance_indicator TEXT NOT NULL, former_state TEXT NOT NULL, q1_target TEXT, q2_target TEXT, q3_target TEXT, q4_target TEXT, total TEXT, responsible_officer_unit TEXT NOT NULL, total_budgetary_requirements TEXT NOT NULL, remarks TEXT, position INTEGER NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Add indexes for indicator table CREATE INDEX idx_op_activity_indicator_activity_id ON op_activity_indicator(op_activity_id); CREATE INDEX idx_op_activity_indicator_position ON op_activity_indicator(position, op_activity_id); -- Add trigger for indicator table CREATE TRIGGER set_updated_at BEFORE UPDATE ON op_activity_indicator FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241221025056_create_view_op_activities.sql

```sql
-- Create updated operational plan activities view CREATE OR REPLACE VIEW operational_plan_activities AS SELECT op.id AS operational_plan_id, op.title AS operational_plan_title, op.implementing_unit, op.creator_id, op.unit_id, op.office_id, op.program_id, op.review_by, op.reviewer_position, op.approve_by, op.approver_position, h.id AS header_id, h.title AS header_title, h.position AS header_position, ap.id AS annual_plan_id, ap.description AS annual_plan_description, ap.position AS annual_plan_position, act.id AS activity_id, act.activity, act.position AS activity_position, ind.id AS indicator_id, ind.input_type, ind.performance_indicator, ind.former_state, ind.q1_target, ind.q2_target, ind.q3_target, ind.q4_target, ind.total, ind.responsible_officer_unit, ind.total_budgetary_requirements, ind.position AS indicator_position, act.created_at AS activity_created_at, act.updated_at AS activity_updated_at, ind.created_at AS indicator_created_at, ind.updated_at AS indicator_updated_at FROM operational_plan op LEFT JOIN op_header h ON op.id = h.operational_plan_id LEFT JOIN op_annual_plan ap ON h.id = ap.op_header_id LEFT JOIN op_activity act ON ap.id = act.op_annual_plan_id LEFT JOIN op_activity_indicator ind ON act.id = ind.op_activity_id ORDER BY op.id, h.position, ap.position, act.position, ind.position; -- Grant select permission to authenticated users GRANT SELECT ON operational_plan_activities TO authenticated;
```

# 20241221025057_create_op_validator.sql

```sql
-- First safely drop the type if it exists DO $$ BEGIN IF EXISTS (SELECT 1 FROM pg_type WHERE typname = 'validation_result') THEN DROP TYPE validation_result CASCADE; END IF; END $$; -- Create the composite type CREATE TYPE validation_result AS ( is_valid boolean, validation_message text ); -- Create the validation function CREATE OR REPLACE FUNCTION validate_operational_plan(p_operational_plan_id UUID) RETURNS validation_result LANGUAGE plpgsql AS $$ DECLARE result validation_result; invalid_header RECORD; invalid_annual_plan RECORD; invalid_activity RECORD; invalid_indicator RECORD; BEGIN -- Check if operational plan has at least one header IF NOT EXISTS ( SELECT 1 FROM op_header WHERE operational_plan_id = p_operational_plan_id ) THEN result := (false, 'Operational Plan must have at least one header'); RETURN result; END IF; -- Check if each header has at least one annual plan SELECT h.id, h.title INTO invalid_header FROM op_header h WHERE h.operational_plan_id = p_operational_plan_id AND NOT EXISTS ( SELECT 1 FROM op_annual_plan ap WHERE ap.op_header_id = h.id ) LIMIT 1; IF FOUND THEN result := (false, format('Header "%s": No annual plans found', invalid_header.title)); RETURN result; END IF; -- Check if each annual plan has at least one activity SELECT ap.id, ap.description, h.title as header_title INTO invalid_annual_plan FROM op_annual_plan ap JOIN op_header h ON h.id = ap.op_header_id WHERE h.operational_plan_id = p_operational_plan_id AND NOT EXISTS ( SELECT 1 FROM op_activity a WHERE a.op_annual_plan_id = ap.id ) LIMIT 1; IF FOUND THEN result := (false, format('Annual Plan "%s" under header "%s": No activities found', invalid_annual_plan.description, invalid_annual_plan.header_title)); RETURN result; END IF; -- Check if each activity has at least one indicator SELECT a.id, a.activity, ap.description as annual_plan_desc, h.title as header_title INTO invalid_activity FROM op_activity a JOIN op_annual_plan ap ON ap.id = a.op_annual_plan_id JOIN op_header h ON h.id = ap.op_header_id WHERE h.operational_plan_id = p_operational_plan_id AND NOT EXISTS ( SELECT 1 FROM op_activity_indicator i WHERE i.op_activity_id = a.id ) LIMIT 1; IF FOUND THEN result := (false, format('Activity "%s" under annual plan "%s" (header: "%s"): No indicators found', invalid_activity.activity, invalid_activity.annual_plan_desc, invalid_activity.header_title)); RETURN result; END IF; -- Check if all indicator fields are filled SELECT i.id, i.performance_indicator, a.activity, ap.description as annual_plan_desc, h.title as header_title, CASE WHEN i.performance_indicator IS NULL THEN 'Performance Indicator' WHEN i.former_state IS NULL THEN 'Former State' WHEN i.responsible_officer_unit IS NULL THEN 'Responsible Officer/Unit' WHEN i.total_budgetary_requirements IS NULL THEN 'Total Budgetary Requirements' END as missing_field INTO invalid_indicator FROM op_activity_indicator i JOIN op_activity a ON a.id = i.op_activity_id JOIN op_annual_plan ap ON ap.id = a.op_annual_plan_id JOIN op_header h ON h.id = ap.op_header_id WHERE h.operational_plan_id = p_operational_plan_id AND ( i.performance_indicator IS NULL OR i.former_state IS NULL OR i.responsible_officer_unit IS NULL OR i.total_budgetary_requirements IS NULL ) LIMIT 1; IF FOUND THEN result := (false, format('Indicator under activity "%s" (annual plan: "%s", header: "%s"): Missing %s', invalid_indicator.activity, invalid_indicator.annual_plan_desc, invalid_indicator.header_title, invalid_indicator.missing_field)); RETURN result; END IF; -- If we get here, everything is valid result := (true, 'Operational Plan is complete and valid'); RETURN result; END; $$; -- Grant execute permission to authenticated users GRANT EXECUTE ON FUNCTION validate_operational_plan(UUID) TO authenticated;
```

# 20241223034318_create_ipcr_table.sql

```sql
-- Create status enum type if it doesn't exist already CREATE TYPE ipcr_status AS ENUM ( 'draft', 'submitted_raw', 'under_review_raw', 'revision_raw', 'reviewed_raw', 'submitted', 'under_review', 'revision', 'approved' ); -- Create ipcr table CREATE TABLE ipcr ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), title VARCHAR(255) NOT NULL, status ipcr_status DEFAULT 'draft' NOT NULL, head_of_operating_unit VARCHAR(255), immediate_supervisor VARCHAR(255), immediate_supervisor_position VARCHAR(255), program_chair VARCHAR(255), dean VARCHAR(255), owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE, unit_id INTEGER REFERENCES unit(id) ON DELETE CASCADE, office_id INTEGER REFERENCES office(id) ON DELETE CASCADE, program_id INTEGER REFERENCES program(id) ON DELETE CASCADE, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Create indexes for foreign keys and common query patterns CREATE INDEX idx_ipcr_owner ON ipcr(owner_id); CREATE INDEX idx_ipcr_unit ON ipcr(unit_id); CREATE INDEX idx_ipcr_office ON ipcr(office_id); CREATE INDEX idx_ipcr_program ON ipcr(program_id); CREATE INDEX idx_ipcr_status ON ipcr(status); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON ipcr FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241223075628_create_ipcr_function_table.sql

```sql
-- Create ipcr_function table CREATE TABLE ipcr_function ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), title VARCHAR(255) NOT NULL, percentage integer NOT NULL, ipcr_id UUID REFERENCES ipcr(id) ON DELETE CASCADE NOT NULL, position INTEGER NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, UNIQUE(ipcr_id, title) ); -- Add index for better query performance when ordering by position CREATE INDEX idx_ipcr_function_position ON ipcr_function(position, ipcr_id); -- Add index for foreign key CREATE INDEX idx_ipcr_function_ipcr_id ON ipcr_function(ipcr_id); -- Add trigger for updating the updated_at timestamp CREATE TRIGGER set_updated_at BEFORE UPDATE ON ipcr_function FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241223175944_create_ipcr_category_table.sql

```sql
-- Create ipcr_function_category table CREATE TABLE ipcr_function_category ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), ipcr_function_id UUID REFERENCES ipcr_function(id) ON DELETE CASCADE NOT NULL, category VARCHAR(255) NOT NULL, unit NUMERIC(4,2), immediate_supervisor_id UUID REFERENCES auth.users(id), position SMALLINT NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, UNIQUE(category, ipcr_function_id) ); -- Add index for foreign key references and position ordering CREATE INDEX idx_ipcr_function_category_function_id ON ipcr_function_category(ipcr_function_id); CREATE INDEX idx_ipcr_function_category_position ON ipcr_function_category(position, ipcr_function_id); CREATE INDEX idx_ipcr_function_category_supervisor_id ON ipcr_function_category(immediate_supervisor_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON ipcr_function_category FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241224134050_create_ipcr_sub_category_table.sql

```sql
-- Create ipcr_function_sub_category table CREATE TABLE ipcr_function_sub_category ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), ipcr_function_category_id UUID REFERENCES ipcr_function_category(id) ON DELETE CASCADE NOT NULL, sub_category VARCHAR(255) NOT NULL, position INTEGER NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Add indexes for better query performance CREATE INDEX idx_ipcr_function_sub_category_category_id ON ipcr_function_sub_category(ipcr_function_category_id); CREATE INDEX idx_ipcr_function_sub_category_position ON ipcr_function_sub_category(position, ipcr_function_category_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON ipcr_function_sub_category FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241224140105_create_ipcr_indicator_table.sql

```sql
-- Create ipcr_indicator table CREATE TABLE ipcr_indicator ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), ipcr_function_id UUID REFERENCES ipcr_function(id) ON DELETE CASCADE, ipcr_function_sub_category_id UUID REFERENCES ipcr_function_sub_category(id) ON DELETE CASCADE, ipcr_function_category_id UUID REFERENCES ipcr_function_category(id) ON DELETE CASCADE, final_output TEXT NOT NULL, success_indicator TEXT NOT NULL, op_activity_indicator_id UUID REFERENCES op_activity_indicator(id) ON DELETE SET NULL NOT NULL, quality_rating NUMERIC(3,2), efficiency_rating NUMERIC(3,2), timeliness_rating NUMERIC(3,2), average_rating NUMERIC(3,2), remarks TEXT, position SMALLINT NOT NULL, immediate_supervisor_id UUID REFERENCES auth.users(id) ON DELETE SET NULL, units NUMERIC(4,2), created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Add indexes for foreign key relationships and common query patterns CREATE INDEX idx_ipcr_indicator_function_id ON ipcr_indicator(ipcr_function_id); CREATE INDEX idx_ipcr_indicator_sub_category_id ON ipcr_indicator(ipcr_function_sub_category_id); CREATE INDEX idx_ipcr_indicator_category_id ON ipcr_indicator(ipcr_function_category_id); CREATE INDEX idx_ipcr_indicator_op_activity_indicator_id ON ipcr_indicator(op_activity_indicator_id); CREATE INDEX idx_ipcr_indicator_immediate_supervisor ON ipcr_indicator(immediate_supervisor_id); -- Add composite index for position ordering within categories CREATE INDEX idx_ipcr_indicator_position ON ipcr_indicator(position, ipcr_function_category_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON ipcr_indicator FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241224140106_create_ipcr_indicator_accomplishment.sql.sql

```sql
-- First create the new indicator_accomplishment table CREATE TABLE ipcr_indicator_accomplishment ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), ipcr_indicator_id UUID REFERENCES ipcr_indicator(id) ON DELETE CASCADE NOT NULL, actual_accomplishments TEXT NOT NULL, accomplishment_date DATE NOT NULL, quantity TEXT NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Create indexes for better query performance CREATE INDEX idx_indicator_accomplishment_indicator_id ON ipcr_indicator_accomplishment(ipcr_indicator_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON ipcr_indicator_accomplishment FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241226123705_create_ipcr_submit_checker.sql

```sql
-- Create the validation function CREATE OR REPLACE FUNCTION validate_ipcr(p_ipcr_id UUID) RETURNS validation_result LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$ DECLARE result validation_result; invalid_function RECORD; invalid_indicator RECORD; BEGIN -- Check if IPCR has at least one function IF NOT EXISTS ( SELECT 1 FROM ipcr_function WHERE ipcr_id = p_ipcr_id ) THEN result := ROW(false, 'IPCR must have at least one function')::validation_result; RETURN result; END IF; -- Check if each function has at least one indicator SELECT f.id, f.title INTO invalid_function FROM ipcr_function f WHERE f.ipcr_id = p_ipcr_id AND NOT EXISTS ( -- Check direct function indicators SELECT 1 FROM ipcr_indicator i WHERE i.ipcr_function_id = f.id UNION ALL -- Check category indicators SELECT 1 FROM ipcr_function_category fc JOIN ipcr_indicator i ON i.ipcr_function_category_id = fc.id WHERE fc.ipcr_function_id = f.id UNION ALL -- Check subcategory indicators SELECT 1 FROM ipcr_function_category fc JOIN ipcr_function_sub_category fsc ON fsc.ipcr_function_category_id = fc.id JOIN ipcr_indicator i ON i.ipcr_function_sub_category_id = fsc.id WHERE fc.ipcr_function_id = f.id ) LIMIT 1; IF FOUND THEN result := ROW(false, format('Function "%s": No indicators found at any level', invalid_function.title))::validation_result; RETURN result; END IF; -- Check basic requirements for all indicators SELECT CASE WHEN i.final_output IS NULL THEN 'Missing Final Output' WHEN i.success_indicator IS NULL THEN 'Missing Success Indicator' WHEN i.op_activity_indicator_id IS NULL THEN 'Missing Operational Plan Activity' END as missing_field, COALESCE(f.title, fc.category, fsc.sub_category) as parent_name INTO invalid_indicator FROM ipcr_indicator i LEFT JOIN ipcr_function f ON f.id = i.ipcr_function_id LEFT JOIN ipcr_function_category fc ON fc.id = i.ipcr_function_category_id LEFT JOIN ipcr_function_sub_category fsc ON fsc.id = i.ipcr_function_sub_category_id WHERE (f.ipcr_id = p_ipcr_id OR EXISTS(SELECT 1 FROM ipcr_function parent_f WHERE parent_f.ipcr_id = p_ipcr_id AND fc.ipcr_function_id = parent_f.id)) AND ( i.final_output IS NULL OR i.success_indicator IS NULL OR i.op_activity_indicator_id IS NULL ) LIMIT 1; IF FOUND THEN result := ROW(false, format('In %s: %s', invalid_indicator.parent_name, invalid_indicator.missing_field))::validation_result; RETURN result; END IF; -- Special check for indicators directly under function SELECT CASE WHEN i.immediate_supervisor_id IS NULL THEN 'Missing Immediate Supervisor' WHEN i.units IS NULL THEN 'Missing Units' END as missing_field, f.title as function_title INTO invalid_indicator FROM ipcr_indicator i JOIN ipcr_function f ON f.id = i.ipcr_function_id WHERE f.ipcr_id = p_ipcr_id AND i.ipcr_function_category_id IS NULL AND i.ipcr_function_sub_category_id IS NULL AND ( i.immediate_supervisor_id IS NULL OR i.units IS NULL ) LIMIT 1; IF FOUND THEN result := ROW(false, format('Direct indicator under function "%s": %s', invalid_indicator.function_title, invalid_indicator.missing_field))::validation_result; RETURN result; END IF; -- If we get here, everything is valid result := ROW(true, 'IPCR is complete and valid')::validation_result; RETURN result; END; $$; -- Grant necessary permissions GRANT EXECUTE ON FUNCTION validate_ipcr(UUID) TO authenticated;
```

# 20241226123706_create_ipcr_evidence_table.sql

```sql
-- Create evidence table with updated reference CREATE TABLE ipcr_indicator_evidence ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), ipcr_indicator_accomplishment_id UUID REFERENCES ipcr_indicator_accomplishment(id) ON DELETE CASCADE NOT NULL, file_path TEXT NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Create index for better query performance CREATE INDEX idx_ipcr_indicator_evidence_accomplishment_id ON ipcr_indicator_evidence(ipcr_indicator_accomplishment_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON ipcr_indicator_evidence FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241226123707_ipcr_backup_view.sql

```sql
CREATE OR REPLACE VIEW ipcr_backup_view AS SELECT i.id as ipcr_id, i.title as ipcr_title, i.status as ipcr_status, i.head_of_operating_unit, i.immediate_supervisor, i.immediate_supervisor_position, i.program_chair, i.dean, -- Owner details p.id as owner_id, p.employee_id as owner_employee_id, p.first_name as owner_first_name, p.middle_name as owner_middle_name, p.last_name as owner_last_name, p.email as owner_email, pos.name as owner_position_name, now_type.type as owner_nature_of_work, emp_status.type as owner_employee_status, -- Owner organization owner_unit.id as owner_unit_id, owner_unit.code as owner_unit_code, owner_unit.name as owner_unit_name, owner_office.id as owner_office_id, owner_office.code as owner_office_code, owner_office.name as owner_office_name, owner_program.id as owner_program_id, owner_program.name as owner_program_name, -- IPCR organization ipcr_unit.id as ipcr_unit_id, ipcr_unit.code as ipcr_unit_code, ipcr_unit.name as ipcr_unit_name, ipcr_office.id as ipcr_office_id, ipcr_office.code as ipcr_office_code, ipcr_office.name as ipcr_office_name, ipcr_program.id as ipcr_program_id, ipcr_program.name as ipcr_program_name, -- Function details f.id as function_id, f.title as function_title, f.percentage as function_percentage, f.position as function_position, -- Category details fc.id as category_id, fc.category, fc.unit as category_unit, fc.position as category_position, cat_sup_profile.employee_id as category_supervisor_employee_id, cat_sup_profile.first_name as category_supervisor_first_name, cat_sup_profile.middle_name as category_supervisor_middle_name, cat_sup_profile.last_name as category_supervisor_last_name, cat_sup_pos.name as category_supervisor_position, -- Subcategory details fsc.id as subcategory_id, fsc.sub_category, fsc.position as subcategory_position, -- Indicator details ind.id as indicator_id, ind.final_output, ind.success_indicator, ind.units as indicator_units, ind.quality_rating, ind.efficiency_rating, ind.timeliness_rating, ind.average_rating, ind.remarks as indicator_remarks, ind.position as indicator_position, -- Accomplishment details ia.id as accomplishment_id, ia.actual_accomplishments, ia.accomplishment_date, ia.quantity, -- Indicator supervisor details ind_sup_profile.employee_id as indicator_supervisor_employee_id, ind_sup_profile.first_name as indicator_supervisor_first_name, ind_sup_profile.middle_name as indicator_supervisor_middle_name, ind_sup_profile.last_name as indicator_supervisor_last_name, ind_sup_pos.name as indicator_supervisor_position, -- Operational plan details op_act.activity as op_activity, op_ind.performance_indicator as op_performance_indicator, op_ind.input_type as op_input_type, op_ind.former_state as op_former_state, op_ind.q1_target as op_q1_target, op_ind.q2_target as op_q2_target, op_ind.q3_target as op_q3_target, op_ind.q4_target as op_q4_target, op_ind.total as op_total, op_ind.responsible_officer_unit as op_responsible_officer_unit, op_ind.total_budgetary_requirements as op_total_budgetary_requirements, -- Evidence files with inner join to ensure only valid accomplishments ( SELECT json_agg ( json_build_object ( 'id', e.id, 'file_path', e.file_path, 'created_at', e.created_at ) ) FROM ipcr_indicator_evidence e JOIN ipcr_indicator_accomplishment ia2 ON e.ipcr_indicator_accomplishment_id = ia2.id WHERE ia2.ipcr_indicator_id = ind.id ) as evidence_files, i.created_at, i.updated_at FROM ipcr i LEFT JOIN profiles p ON i.owner_id = p.id LEFT JOIN position pos ON p.position_id = pos.id LEFT JOIN nature_of_work now_type ON p.nature_of_work_id = now_type.id LEFT JOIN employee_status emp_status ON p.employee_status_id = emp_status.id LEFT JOIN unit owner_unit ON p.unit_id = owner_unit.id LEFT JOIN office owner_office ON p.office_id = owner_office.id LEFT JOIN program owner_program ON p.program_id = owner_program.id LEFT JOIN unit ipcr_unit ON i.unit_id = ipcr_unit.id LEFT JOIN office ipcr_office ON i.office_id = ipcr_office.id LEFT JOIN program ipcr_program ON i.program_id = ipcr_program.id LEFT JOIN ipcr_function f ON i.id = f.ipcr_id LEFT JOIN ipcr_function_category fc ON f.id = fc.ipcr_function_id LEFT JOIN ipcr_function_sub_category fsc ON fc.id = fsc.ipcr_function_category_id LEFT JOIN profiles cat_sup_profile ON fc.immediate_supervisor_id = cat_sup_profile.id LEFT JOIN position cat_sup_pos ON cat_sup_profile.position_id = cat_sup_pos.id LEFT JOIN ipcr_indicator ind ON ( ind.ipcr_function_id = f.id OR ind.ipcr_function_category_id = fc.id OR ind.ipcr_function_sub_category_id = fsc.id ) LEFT JOIN ipcr_indicator_accomplishment ia ON ind.id = ia.ipcr_indicator_id LEFT JOIN profiles ind_sup_profile ON ind.immediate_supervisor_id = ind_sup_profile.id LEFT JOIN position ind_sup_pos ON ind_sup_profile.position_id = ind_sup_pos.id LEFT JOIN op_activity_indicator op_ind ON ind.op_activity_indicator_id = op_ind.id LEFT JOIN op_activity op_act ON op_ind.op_activity_id = op_act.id; -- Grant select permission GRANT SELECT ON ipcr_backup_view TO authenticated;
```

# 20241226155655_create_evidence_storage.sql

```sql
-- Create a new storage bucket for evidence files insert into storage.buckets (id, name, public) values ('indicator_evidence', 'indicator_evidence', false); -- Set up access control policies for evidence files CREATE POLICY "User can upload their own evidence files" ON storage.objects FOR INSERT WITH CHECK ( bucket_id = 'indicator_evidence' AND auth.uid()::text = (storage.foldername(name))[1] ); -- Allow anyone to read evidence files CREATE POLICY "Can read evidence files" ON storage.objects FOR SELECT TO public USING (bucket_id = 'indicator_evidence'); -- Allow anyone to update their own evidence files CREATE POLICY "User can update their own evidence files" ON storage.objects FOR UPDATE USING ( bucket_id = 'indicator_evidence' AND auth.uid()::text = (storage.foldername(name))[1] );
```

# 20241229162216_create_accomplishment_report_table.sql

```sql
-- Create status enum type if it doesn't exist -- CREATE TYPE accomplishment_status AS ENUM ('draft', 'submitted', 'reviewing', 'revision', 'approved'); -- Create accomplishment_report table CREATE TABLE accomplishment_report ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), title VARCHAR(255) NOT NULL, implementing_unit TEXT NOT NULL, -- status accomplishment_status DEFAULT 'draft' NOT NULL, -- IDs and references owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL, unit_id INTEGER REFERENCES unit(id) ON DELETE CASCADE, office_id INTEGER REFERENCES office(id) ON DELETE CASCADE, program_id INTEGER REFERENCES program(id) ON DELETE CASCADE, -- Review/approval information review_by VARCHAR(255) NOT NULL, reviewer_position VARCHAR(255) NOT NULL, approve_by VARCHAR(255) NOT NULL, approver_position VARCHAR(255) NOT NULL, -- Timestamps created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Create indexes for foreign keys and common query patterns CREATE INDEX idx_accomplishment_report_owner ON accomplishment_report(owner_id); CREATE INDEX idx_accomplishment_report_unit ON accomplishment_report(unit_id); CREATE INDEX idx_accomplishment_report_office ON accomplishment_report(office_id); CREATE INDEX idx_accomplishment_report_program ON accomplishment_report(program_id); -- CREATE INDEX idx_accomplishment_report_status ON accomplishment_report(status); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON accomplishment_report FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241229170523_create_accomplishment_header.sql

```sql
-- Create accomplishment_header table CREATE TABLE accomplishment_header ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), accomplishment_report_id UUID REFERENCES accomplishment_report(id) ON DELETE CASCADE NOT NULL, position INTEGER NOT NULL, title TEXT NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Add indexes for better query performance CREATE INDEX idx_accomplishment_header_report_id ON accomplishment_header(accomplishment_report_id); CREATE INDEX idx_accomplishment_header_position ON accomplishment_header(position, accomplishment_report_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON accomplishment_header FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241229171016_create_accomplishment_annual_plan.sql

```sql
-- Create accomplishment_annual_plan table CREATE TABLE accomplishment_annual_plan ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), accomplishment_header_id UUID REFERENCES accomplishment_header(id) ON DELETE CASCADE NOT NULL, description TEXT NOT NULL, position INTEGER NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Add indexes for better query performance CREATE INDEX idx_accomplishment_annual_plan_header_id ON accomplishment_annual_plan(accomplishment_header_id); CREATE INDEX idx_accomplishment_annual_plan_position ON accomplishment_annual_plan(position, accomplishment_header_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON accomplishment_annual_plan FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20250110172658_create_accomplishment_activity.sql

```sql
-- Create accomplishment_activity table CREATE TABLE accomplishment_activity ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), accomplishment_annual_plan_id UUID REFERENCES accomplishment_annual_plan(id) ON DELETE CASCADE NOT NULL, activity TEXT NOT NULL, position INTEGER NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Add indexes for better query performance CREATE INDEX idx_accomplishment_activity_annual_plan_id ON accomplishment_activity(accomplishment_annual_plan_id); CREATE INDEX idx_accomplishment_activity_position ON accomplishment_activity(position, accomplishment_annual_plan_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON accomplishment_activity FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20250110172659_create_accomplishment_indicator.sql.sql

```sql
CREATE TYPE input_type_accomplishment AS ENUM ('percentage', 'number', 'ratio', 'text'); -- Create accomplishment_activity_indicator table CREATE TABLE accomplishment_activity_indicator ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), accomplishment_activity_id UUID REFERENCES accomplishment_activity(id) ON DELETE CASCADE NOT NULL, input_type input_type_accomplishment NOT NULL DEFAULT 'text', performance_indicator TEXT NOT NULL, annual_target TEXT NOT NULL, q1_accomplishment TEXT, q2_accomplishment TEXT, q3_accomplishment TEXT, q4_accomplishment TEXT, total TEXT, accomplishment_rate TEXT, responsible_officer_unit TEXT NOT NULL, remarks TEXT, position INTEGER NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Add indexes for better query performance CREATE INDEX idx_accomplishment_activity_indicator_activity_id ON accomplishment_activity_indicator(accomplishment_activity_id); CREATE INDEX idx_accomplishment_activity_indicator_position ON accomplishment_activity_indicator(position, accomplishment_activity_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON accomplishment_activity_indicator FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20250121104852_create_view_ipcr_supervisor.sql

```sql
CREATE OR REPLACE VIEW ipcr_supervisors AS WITH combined_supervisors AS ( -- Get supervisors from categories and indicators SELECT DISTINCT f.ipcr_id, fc.immediate_supervisor_id FROM ipcr_function_category fc JOIN ipcr_function f ON f.id = fc.ipcr_function_id WHERE fc.immediate_supervisor_id IS NOT NULL UNION SELECT DISTINCT f.ipcr_id, i.immediate_supervisor_id FROM ipcr_indicator i JOIN ipcr_function f ON f.id = i.ipcr_function_id WHERE i.immediate_supervisor_id IS NOT NULL ) SELECT DISTINCT ON (cs.ipcr_id, cs.immediate_supervisor_id) cs.ipcr_id, cs.immediate_supervisor_id as id, p.first_name || ' ' || CASE WHEN p.middle_name IS NOT NULL AND p.middle_name != '' THEN p.middle_name || ' ' ELSE '' END || p.last_name as full_name, pos.name as position FROM combined_supervisors cs JOIN profiles p ON p.id = cs.immediate_supervisor_id LEFT JOIN position pos ON pos.id = p.position_id ORDER BY cs.ipcr_id, cs.immediate_supervisor_id, full_name; -- Grant necessary permissions GRANT SELECT ON ipcr_supervisors TO authenticated;
```

# 20250123092946_create_table_dpcr.sql

```sql
-- Create dpcr table CREATE TABLE dpcr ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), title VARCHAR(255) NOT NULL, review_by VARCHAR(255) NOT NULL, reviewer_position VARCHAR(255) NOT NULL, owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL, unit_id INTEGER REFERENCES unit(id) ON DELETE CASCADE, office_id INTEGER REFERENCES office(id) ON DELETE CASCADE, program_id INTEGER REFERENCES program(id) ON DELETE CASCADE, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Create indexes for foreign keys and common query patterns CREATE INDEX idx_dpcr_owner ON dpcr(owner_id); CREATE INDEX idx_dpcr_unit ON dpcr(unit_id); CREATE INDEX idx_dpcr_office ON dpcr(office_id); CREATE INDEX idx_dpcr_program ON dpcr(program_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON dpcr FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20250123093905_create_table_dpcr_assesor.sql

```sql
-- Create dpcr_assessors table CREATE TABLE dpcr_assessor ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), dpcr_id UUID REFERENCES dpcr(id) ON DELETE CASCADE NOT NULL, name VARCHAR(255) NOT NULL, position VARCHAR(255) NOT NULL, sequence INTEGER DEFAULT 0 NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Create indexes for better query performance CREATE INDEX idx_dpcr_assessor_dpcr_id ON dpcr_assessor(dpcr_id); CREATE INDEX idx_dpcr_assessor_sequence ON dpcr_assessor(sequence, dpcr_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON dpcr_assessor FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20250123094143_create_table_dpcr_function.sql

```sql
-- Create dpcr_function table CREATE TABLE dpcr_function ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), dpcr_id UUID REFERENCES dpcr(id) ON DELETE CASCADE NOT NULL, title VARCHAR(255) NOT NULL, position INTEGER NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, UNIQUE(dpcr_id, title) ); -- Create indexes for better query performance CREATE INDEX idx_dpcr_function_dpcr_id ON dpcr_function(dpcr_id); CREATE INDEX idx_dpcr_function_position ON dpcr_function(position, dpcr_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON dpcr_function FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20250123094232_create_table_dpcr_function_category.sql

```sql
-- Create dpcr_function_category table CREATE TABLE dpcr_function_category ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), dpcr_function_id UUID REFERENCES dpcr_function(id) ON DELETE CASCADE NOT NULL, category VARCHAR(255) NOT NULL, position SMALLINT NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, UNIQUE(category, dpcr_function_id) ); -- Create indexes for better query performance CREATE INDEX idx_dpcr_function_category_function_id ON dpcr_function_category(dpcr_function_id); CREATE INDEX idx_dpcr_function_category_position ON dpcr_function_category(position, dpcr_function_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON dpcr_function_category FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20250123094635_create_table_dpcr_indicator.sql

```sql
-- Create dpcr_indicator table CREATE TABLE dpcr_indicator ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), dpcr_function_id UUID REFERENCES dpcr_function(id) ON DELETE CASCADE, dpcr_function_category_id UUID REFERENCES dpcr_function_category(id) ON DELETE CASCADE, success_indicator TEXT NOT NULL, alloted_budget TEXT, division_individuals_accountable TEXT, physical_targets TEXT, actual_accomplishments TEXT, quality_rating NUMERIC(3,2), efficiency_rating NUMERIC(3,2), timeliness_rating NUMERIC(3,2), average_rating NUMERIC(3,2), remarks TEXT, position INTEGER NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Create indexes for better query performance CREATE INDEX idx_dpcr_indicator_function_id ON dpcr_indicator(dpcr_function_id); CREATE INDEX idx_dpcr_indicator_category_id ON dpcr_indicator(dpcr_function_category_id); CREATE INDEX idx_dpcr_indicator_position ON dpcr_indicator(position, dpcr_function_category_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON dpcr_indicator FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20250127132058_create_table_strategic_plan.sql

```sql
-- 20250128143622_add_years_to_strategic_plan.sql -- Create major output enum type CREATE TYPE strategic_major_output AS ENUM ( 'instruction', 'research', 'extension', 'governance_and_management' ); -- Create strategic_plan table CREATE TABLE strategic_plan ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), title VARCHAR(255) NOT NULL, major_output strategic_major_output NOT NULL, goal TEXT NOT NULL, start_year INTEGER NOT NULL CHECK (start_year >= EXTRACT(YEAR FROM NOW())), end_year INTEGER NOT NULL CHECK (end_year >= EXTRACT(YEAR FROM NOW())), owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL, unit_id INTEGER REFERENCES unit(id) ON DELETE CASCADE, office_id INTEGER REFERENCES office(id) ON DELETE CASCADE, program_id INTEGER REFERENCES program(id) ON DELETE CASCADE, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, CONSTRAINT end_year_after_start CHECK (end_year >= start_year) ); -- Create indexes for foreign keys and common query patterns CREATE INDEX idx_strategic_plan_owner ON strategic_plan(owner_id); CREATE INDEX idx_strategic_plan_unit ON strategic_plan(unit_id); CREATE INDEX idx_strategic_plan_office ON strategic_plan(office_id); CREATE INDEX idx_strategic_plan_program ON strategic_plan(program_id); CREATE INDEX idx_strategic_plan_major_output ON strategic_plan(major_output); CREATE INDEX idx_strategic_plan_years ON strategic_plan(start_year, end_year); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON strategic_plan FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20250127132919_create_table_strategic_plan_objectives.sql

```sql
-- Create strat_plan_objective table CREATE TABLE strat_plan_objective ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), strategic_plan_id UUID REFERENCES strategic_plan(id) ON DELETE CASCADE NOT NULL, objective TEXT NOT NULL, position INTEGER NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, -- Ensure objective is unique per strategic plan UNIQUE(strategic_plan_id, objective) ); -- Create indexes for better query performance CREATE INDEX idx_strat_plan_objective_strategic_plan_id ON strat_plan_objective(strategic_plan_id); CREATE INDEX idx_strat_plan_objective_position ON strat_plan_objective(position, strategic_plan_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON strat_plan_objective FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20250128122622_create_table_strategy_plan.sql

```sql
-- Create strategy_plan table CREATE TABLE strategy_plan ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), strat_plan_id UUID REFERENCES strategic_plan(id) ON DELETE CASCADE NOT NULL, description TEXT NOT NULL, position INTEGER NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, -- Ensure description is unique per strategic plan UNIQUE(strat_plan_id, description) ); -- Create indexes for better query performance CREATE INDEX idx_strategy_plan_strat_plan_id ON strategy_plan(strat_plan_id); CREATE INDEX idx_strategy_plan_position ON strategy_plan(position, strat_plan_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON strategy_plan FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20250128165836_create_table_strategy_plan_performance_indicator_table.sql

```sql
-- Create the input type enum CREATE TYPE input_type_strategic_plan AS ENUM ('percentage', 'number', 'ratio', 'text'); -- Recreate strategy_plan_performance_indicator table with new column CREATE TABLE strategy_plan_performance_indicator ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), strategy_plan_id UUID REFERENCES strategy_plan(id) ON DELETE CASCADE NOT NULL, performance_indicator TEXT NOT NULL, input_type input_type_strategic_plan NOT NULL DEFAULT 'text', base_target TEXT NOT NULL, actual_target TEXT NOT NULL, concerned_offices TEXT, remarks TEXT, position INTEGER NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Create indexes for better query performance CREATE INDEX idx_strategy_plan_performance_indicator_strategy_plan_id ON strategy_plan_performance_indicator(strategy_plan_id); CREATE INDEX idx_strategy_plan_performance_indicator_position ON strategy_plan_performance_indicator(position, strategy_plan_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON strategy_plan_performance_indicator FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20250128170002_create_table_sdg_alignment_table_view.sql

```sql
-- Create sdg_alignment table CREATE TABLE sdg_alignment ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), strat_plan_objective_id UUID REFERENCES strat_plan_objective(id) ON DELETE CASCADE NOT NULL, strat_plan_performance_indicator_id UUID REFERENCES strategy_plan_performance_indicator(id) ON DELETE CASCADE NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, -- Ensure unique combination of objective and performance indicator UNIQUE(strat_plan_objective_id, strat_plan_performance_indicator_id) ); -- Create indexes for foreign keys CREATE INDEX idx_sdg_alignment_objective_id ON sdg_alignment(strat_plan_objective_id); CREATE INDEX idx_sdg_alignment_performance_indicator_id ON sdg_alignment(strat_plan_performance_indicator_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON sdg_alignment FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at(); -- Create view for SDG alignments with related data CREATE OR REPLACE VIEW sdg_alignment_view AS SELECT sa.id as alignment_id, sa.created_at as alignment_created_at, sa.updated_at as alignment_updated_at, -- Strategic Plan data sp.id as strategic_plan_id, sp.title as strategic_plan_title, sp.major_output, sp.goal as strategic_plan_goal, -- Objective data spo.id as objective_id, spo.objective, spo.position as objective_position, -- Performance Indicator data sppi.id as performance_indicator_id, sppi.base_target, sppi.actual_target, sppi.concerned_offices, sppi.remarks as performance_indicator_remarks, sppi.position as performance_indicator_position FROM sdg_alignment sa JOIN strat_plan_objective spo ON sa.strat_plan_objective_id = spo.id JOIN strategy_plan_performance_indicator sppi ON sa.strat_plan_performance_indicator_id = sppi.id JOIN strategic_plan sp ON spo.strategic_plan_id = sp.id; -- Grant necessary permissions GRANT SELECT ON sdg_alignment_view TO authenticated;
```

# 20250128170045_create_table_strat_plan_yearly_plan.sql

```sql
-- Create strat_plan_yearly_plan table CREATE TABLE strat_plan_yearly_plan ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), strategy_plan_performance_indicator_id UUID REFERENCES strategy_plan_performance_indicator(id) ON DELETE CASCADE NOT NULL, year INTEGER NOT NULL, target TEXT NOT NULL, budget NUMERIC NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, -- Ensure unique combination of performance indicator and year UNIQUE(strategy_plan_performance_indicator_id, year) ); -- Create index for foreign key CREATE INDEX idx_strat_plan_yearly_plan_performance_indicator_id ON strat_plan_yearly_plan(strategy_plan_performance_indicator_id); -- Create index for year queries CREATE INDEX idx_strat_plan_yearly_plan_year ON strat_plan_yearly_plan(year); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON strat_plan_yearly_plan FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20250131164632_create_table_opcr.sql

```sql
-- Create opcr table CREATE TABLE opcr ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), title VARCHAR(255) NOT NULL, review_by VARCHAR(255) NOT NULL, reviewer_position VARCHAR(255) NOT NULL, administrative_officer VARCHAR(255) NOT NULL, planning_officer VARCHAR(255) NOT NULL, human_resource VARCHAR(255) NOT NULL, owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL, unit_id INTEGER REFERENCES unit(id) ON DELETE CASCADE, office_id INTEGER REFERENCES office(id) ON DELETE CASCADE, program_id INTEGER REFERENCES program(id) ON DELETE CASCADE, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Create indexes for foreign keys and common query patterns CREATE INDEX idx_opcr_owner ON opcr(owner_id); CREATE INDEX idx_opcr_unit ON opcr(unit_id); CREATE INDEX idx_opcr_office ON opcr(office_id); CREATE INDEX idx_opcr_program ON opcr(program_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON opcr FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20250131164807_create_table_opcr_function.sql

```sql
-- Create opcr_function table CREATE TABLE opcr_function ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), opcr_id UUID REFERENCES opcr(id) ON DELETE CASCADE NOT NULL, title VARCHAR(255) NOT NULL, position INTEGER NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, UNIQUE(opcr_id, title) ); -- Create indexes for better query performance CREATE INDEX idx_opcr_function_opcr_id ON opcr_function(opcr_id); CREATE INDEX idx_opcr_function_position ON opcr_function(position, opcr_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON opcr_function FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20250131164956_create_table_opcr_function_category.sql

```sql
-- Create opcr_function_category table CREATE TABLE opcr_function_category ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), opcr_function_id UUID REFERENCES opcr_function(id) ON DELETE CASCADE NOT NULL, category VARCHAR(255) NOT NULL, position SMALLINT NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, UNIQUE(category, opcr_function_id) ); -- Create indexes for better query performance CREATE INDEX idx_opcr_function_category_function_id ON opcr_function_category(opcr_function_id); CREATE INDEX idx_opcr_function_category_position ON opcr_function_category(position, opcr_function_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON opcr_function_category FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20250131165054_create_table_opcr_function_indicator.sql

```sql
-- Create opcr_indicator table -- Create opcr_indicator table CREATE TABLE opcr_indicator ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), opcr_function_id UUID REFERENCES opcr_function(id) ON DELETE CASCADE, opcr_function_category_id UUID REFERENCES opcr_function_category(id) ON DELETE CASCADE, success_indicator TEXT NOT NULL, alloted_budget TEXT, division_individuals_accountable TEXT, actual_accomplishments TEXT, quality_rating NUMERIC(3,2), efficiency_rating NUMERIC(3,2), timeliness_rating NUMERIC(3,2), average_rating NUMERIC(3,2), remarks TEXT, position INTEGER NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Create indexes for better query performance CREATE INDEX idx_opcr_indicator_function_id ON opcr_indicator(opcr_function_id); CREATE INDEX idx_opcr_indicator_category_id ON opcr_indicator(opcr_function_category_id); CREATE INDEX idx_opcr_indicator_position ON opcr_indicator(position, opcr_function_category_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON opcr_indicator FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20250203065721_create_function_get_ipcr_id_from_indicator.sql

```sql
CREATE OR REPLACE FUNCTION get_ipcr_id_from_indicator(p_indicator_id UUID) RETURNS UUID LANGUAGE plpgsql AS $$ DECLARE v_ipcr_id UUID; BEGIN -- Try to get IPCR ID through function SELECT f.ipcr_id INTO v_ipcr_id FROM ipcr_indicator i JOIN ipcr_function f ON i.ipcr_function_id = f.id WHERE i.id = p_indicator_id; -- If not found, try through category IF v_ipcr_id IS NULL THEN SELECT f.ipcr_id INTO v_ipcr_id FROM ipcr_indicator i JOIN ipcr_function_category fc ON i.ipcr_function_category_id = fc.id JOIN ipcr_function f ON fc.ipcr_function_id = f.id WHERE i.id = p_indicator_id; END IF; -- If still not found, try through sub-category IF v_ipcr_id IS NULL THEN SELECT f.ipcr_id INTO v_ipcr_id FROM ipcr_indicator i JOIN ipcr_function_sub_category fsc ON i.ipcr_function_sub_category_id = fsc.id JOIN ipcr_function_category fc ON fsc.ipcr_function_category_id = fc.id JOIN ipcr_function f ON fc.ipcr_function_id = f.id WHERE i.id = p_indicator_id; END IF; RETURN v_ipcr_id; END; $$;
```

# 20250203125746_create_table_blockchain_data.sql

```sql
-- Create blockchain_data table CREATE TABLE blockchain_data ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), file_cid TEXT NOT NULL, action TEXT NOT NULL DEFAULT 'backup', file_name TEXT NOT NULL, type TEXT NOT NULL DEFAULT 'data/evidence', blockchain_hash TEXT NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Create indexes for better query performance CREATE INDEX idx_blockchain_data_file_cid ON blockchain_data(file_cid); CREATE INDEX idx_blockchain_data_file_name ON blockchain_data(file_name); CREATE INDEX idx_blockchain_data_type ON blockchain_data(type); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON blockchain_data FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at(); -- Enable Row Level Security ALTER TABLE blockchain_data ENABLE ROW LEVEL SECURITY; -- Create policies for authenticated users CREATE POLICY "Enable read access for all authenticated users" ON blockchain_data FOR SELECT TO authenticated USING (true); CREATE POLICY "Enable insert for authenticated users" ON blockchain_data FOR INSERT TO authenticated WITH CHECK (true);
```

# 20250204155815_create_opeartional_backup_view.sql

```sql
CREATE OR REPLACE VIEW operational_backup_view AS SELECT -- Operational Plan details op.id as operational_plan_id, op.title as operational_plan_title, op.implementing_unit, op.review_by, op.reviewer_position, op.approve_by, op.approver_position, -- Creator Profile details p.id as creator_id, p.employee_id as creator_employee_id, p.first_name as creator_first_name, p.middle_name as creator_middle_name, p.last_name as creator_last_name, p.email as creator_email, -- Creator's Position details pos.name as creator_position_name, now_type.type as creator_nature_of_work, emp_status.type as creator_employee_status, -- Creator's Unit details creator_unit.code as creator_unit_code, creator_unit.name as creator_unit_name, -- Creator's Office details creator_office.code as creator_office_code, creator_office.name as creator_office_name, -- Creator's Program details creator_program.name as creator_program_name, -- Operational Plan Unit details op_unit.code as op_unit_code, op_unit.name as op_unit_name, -- Operational Plan Office details op_office.code as op_office_code, op_office.name as op_office_name, -- Operational Plan Program details op_program.name as op_program_name, -- Header details h.id as header_id, h.title as header_title, h.position as header_position, -- Annual Plan details ap.id as annual_plan_id, ap.description as annual_plan_description, ap.position as annual_plan_position, -- Activity details act.id as activity_id, act.activity, act.position as activity_position, -- Indicator details ind.id as indicator_id, ind.input_type, ind.performance_indicator, ind.former_state, ind.q1_target, ind.q2_target, ind.q3_target, ind.q4_target, ind.total, ind.responsible_officer_unit, ind.total_budgetary_requirements, ind.position as indicator_position, -- Timestamps op.created_at, op.updated_at, act.created_at as activity_created_at, act.updated_at as activity_updated_at, ind.created_at as indicator_created_at, ind.updated_at as indicator_updated_at FROM operational_plan op -- Creator joins LEFT JOIN profiles p ON op.creator_id = p.id LEFT JOIN position pos ON p.position_id = pos.id LEFT JOIN nature_of_work now_type ON p.nature_of_work_id = now_type.id LEFT JOIN employee_status emp_status ON p.employee_status_id = emp_status.id LEFT JOIN unit creator_unit ON p.unit_id = creator_unit.id LEFT JOIN office creator_office ON p.office_id = creator_office.id LEFT JOIN program creator_program ON p.program_id = creator_program.id -- Operational Plan entity joins LEFT JOIN unit op_unit ON op.unit_id = op_unit.id LEFT JOIN office op_office ON op.office_id = op_office.id LEFT JOIN program op_program ON op.program_id = op_program.id -- Operational Plan hierarchy joins LEFT JOIN op_header h ON op.id = h.operational_plan_id LEFT JOIN op_annual_plan ap ON h.id = ap.op_header_id LEFT JOIN op_activity act ON ap.id = act.op_annual_plan_id LEFT JOIN op_activity_indicator ind ON act.id = ind.op_activity_id; -- Grant SELECT permission to authenticated users GRANT SELECT ON operational_backup_view TO authenticated;
```

# 20250204160342_create_dpcr_backup_view.sql

```sql
CREATE OR REPLACE VIEW dpcr_backup_view AS WITH grouped_assessors AS ( SELECT dpcr_id, json_agg ( json_build_object ( 'id', id, 'name', name, 'position', position, 'sequence', sequence ) ORDER BY sequence ) as assessors FROM dpcr_assessor GROUP BY dpcr_id ) SELECT -- DPCR Basic Details d.id as dpcr_id, d.title as dpcr_title, d.review_by, d.reviewer_position, -- Owner Profile Details p.id as owner_id, p.employee_id as owner_employee_id, p.first_name as owner_first_name, p.middle_name as owner_middle_name, p.last_name as owner_last_name, p.email as owner_email, -- Owner Position Details pos.name as owner_position_name, now_type.type as owner_nature_of_work, emp_status.type as owner_employee_status, -- Owner Unit Details owner_unit.id as owner_unit_id, owner_unit.code as owner_unit_code, owner_unit.name as owner_unit_name, -- Owner Office Details owner_office.id as owner_office_id, owner_office.code as owner_office_code, owner_office.name as owner_office_name, -- Owner Program Details owner_program.id as owner_program_id, owner_program.name as owner_program_name, -- DPCR Organization Details dpcr_unit.id as dpcr_unit_id, dpcr_unit.code as dpcr_unit_code, dpcr_unit.name as dpcr_unit_name, dpcr_office.id as dpcr_office_id, dpcr_office.code as dpcr_office_code, dpcr_office.name as dpcr_office_name, dpcr_program.id as dpcr_program_id, dpcr_program.name as dpcr_program_name, -- Assessor Details as JSON array ga.assessors, -- Function Details f.id as function_id, f.title as function_title, f.position as function_position, -- Category Details fc.id as category_id, fc.category, fc.position as category_position, -- Indicator Details ind.id as indicator_id, ind.success_indicator, ind.alloted_budget, ind.division_individuals_accountable, ind.physical_targets, ind.actual_accomplishments, ind.quality_rating, ind.efficiency_rating, ind.timeliness_rating, ind.average_rating, ind.remarks, ind.position as indicator_position, -- Timestamps d.created_at, d.updated_at FROM dpcr d -- Owner joins LEFT JOIN profiles p ON d.owner_id = p.id LEFT JOIN position pos ON p.position_id = pos.id LEFT JOIN nature_of_work now_type ON p.nature_of_work_id = now_type.id LEFT JOIN employee_status emp_status ON p.employee_status_id = emp_status.id LEFT JOIN unit owner_unit ON p.unit_id = owner_unit.id LEFT JOIN office owner_office ON p.office_id = owner_office.id LEFT JOIN program owner_program ON p.program_id = owner_program.id -- DPCR Organization joins LEFT JOIN unit dpcr_unit ON d.unit_id = dpcr_unit.id LEFT JOIN office dpcr_office ON d.office_id = dpcr_office.id LEFT JOIN program dpcr_program ON d.program_id = dpcr_program.id -- Assessors join LEFT JOIN grouped_assessors ga ON d.id = ga.dpcr_id -- DPCR hierarchy joins LEFT JOIN dpcr_function f ON d.id = f.dpcr_id LEFT JOIN dpcr_function_category fc ON f.id = fc.dpcr_function_id LEFT JOIN dpcr_indicator ind ON ( ind.dpcr_function_id = f.id OR ind.dpcr_function_category_id = fc.id ); -- Grant SELECT permission to authenticated users GRANT SELECT ON dpcr_backup_view TO authenticated;
```

# 20250204160856_create_opcr_backup_view.sql

```sql
CREATE OR REPLACE VIEW opcr_backup_view AS SELECT -- OPCR Basic Details o.id as opcr_id, o.title as opcr_title, o.review_by, o.reviewer_position, o.administrative_officer, o.planning_officer, o.human_resource, -- Owner Profile Details p.id as owner_id, p.employee_id as owner_employee_id, p.first_name as owner_first_name, p.middle_name as owner_middle_name, p.last_name as owner_last_name, p.email as owner_email, -- Owner Position Details pos.name as owner_position_name, now_type.type as owner_nature_of_work, emp_status.type as owner_employee_status, -- Owner Unit Details owner_unit.id as owner_unit_id, owner_unit.code as owner_unit_code, owner_unit.name as owner_unit_name, -- Owner Office Details owner_office.id as owner_office_id, owner_office.code as owner_office_code, owner_office.name as owner_office_name, -- Owner Program Details owner_program.id as owner_program_id, owner_program.name as owner_program_name, -- OPCR Organization Details opcr_unit.id as opcr_unit_id, opcr_unit.code as opcr_unit_code, opcr_unit.name as opcr_unit_name, opcr_office.id as opcr_office_id, opcr_office.code as opcr_office_code, opcr_office.name as opcr_office_name, opcr_program.id as opcr_program_id, opcr_program.name as opcr_program_name, -- Function Details f.id as function_id, f.title as function_title, f.position as function_position, -- Category Details fc.id as category_id, fc.category, fc.position as category_position, -- Indicator Details ind.id as indicator_id, ind.success_indicator, ind.alloted_budget, ind.division_individuals_accountable, ind.actual_accomplishments, ind.quality_rating, ind.efficiency_rating, ind.timeliness_rating, ind.average_rating, ind.remarks, ind.position as indicator_position, -- Strategic Plan Alignment Details sp.id as strategic_plan_id, sp.title as strategic_plan_title, sp.major_output as strategic_plan_major_output, sp.goal as strategic_plan_goal, sp.start_year as strategic_plan_start_year, sp.end_year as strategic_plan_end_year, -- Timestamps o.created_at, o.updated_at FROM opcr o -- Owner joins LEFT JOIN profiles p ON o.owner_id = p.id LEFT JOIN position pos ON p.position_id = pos.id LEFT JOIN nature_of_work now_type ON p.nature_of_work_id = now_type.id LEFT JOIN employee_status emp_status ON p.employee_status_id = emp_status.id LEFT JOIN unit owner_unit ON p.unit_id = owner_unit.id LEFT JOIN office owner_office ON p.office_id = owner_office.id LEFT JOIN program owner_program ON p.program_id = owner_program.id -- OPCR Organization joins LEFT JOIN unit opcr_unit ON o.unit_id = opcr_unit.id LEFT JOIN office opcr_office ON o.office_id = opcr_office.id LEFT JOIN program opcr_program ON o.program_id = opcr_program.id -- OPCR hierarchy joins LEFT JOIN opcr_function f ON o.id = f.opcr_id LEFT JOIN opcr_function_category fc ON f.id = fc.opcr_function_id LEFT JOIN opcr_indicator ind ON ( ind.opcr_function_id = f.id OR ind.opcr_function_category_id = fc.id ) -- Strategic Plan join (assuming there might be a relation to strategic plan in the future) LEFT JOIN strategic_plan sp ON ( (o.unit_id = sp.unit_id) AND ( o.office_id IS NULL OR o.office_id = sp.office_id ) AND ( o.program_id IS NULL OR o.program_id = sp.program_id ) AND ( EXTRACT( YEAR FROM o.created_at ) BETWEEN sp.start_year AND sp.end_year ) ); -- Grant SELECT permission to authenticated users GRANT SELECT ON opcr_backup_view TO authenticated;
```

# 20250204160955_create_stategic_plan_backup_view.sql

```sql
CREATE OR REPLACE VIEW strategic_plan_backup_view AS SELECT -- Strategic Plan Basic Details sp.id as strategic_plan_id, sp.title as strategic_plan_title, sp.major_output, sp.goal, sp.start_year, sp.end_year, -- Owner Profile Details p.id as owner_id, p.employee_id as owner_employee_id, p.first_name as owner_first_name, p.middle_name as owner_middle_name, p.last_name as owner_last_name, p.email as owner_email, -- Owner Position Details pos.name as owner_position_name, now_type.type as owner_nature_of_work, emp_status.type as owner_employee_status, -- Owner Unit Details owner_unit.id as owner_unit_id, owner_unit.code as owner_unit_code, owner_unit.name as owner_unit_name, -- Owner Office Details owner_office.id as owner_office_id, owner_office.code as owner_office_code, owner_office.name as owner_office_name, -- Owner Program Details owner_program.id as owner_program_id, owner_program.name as owner_program_name, -- Strategic Plan Organization Details sp_unit.id as sp_unit_id, sp_unit.code as sp_unit_code, sp_unit.name as sp_unit_name, sp_office.id as sp_office_id, sp_office.code as sp_office_code, sp_office.name as sp_office_name, sp_program.id as sp_program_id, sp_program.name as sp_program_name, -- Objective Details obj.id as objective_id, obj.objective, obj.position as objective_position, -- Strategy Details strat.id as strategy_id, strat.description as strategy_description, strat.position as strategy_position, -- Performance Indicator Details pi.id as performance_indicator_id, pi.performance_indicator, pi.input_type, pi.base_target, pi.actual_target, pi.concerned_offices, pi.remarks as pi_remarks, pi.position as pi_position, -- Yearly Plan Details ( SELECT json_agg ( json_build_object ( 'id', yp.id, 'year', yp.year, 'target', yp.target, 'budget', yp.budget ) ORDER BY yp.year ) FROM strat_plan_yearly_plan yp WHERE yp.strategy_plan_performance_indicator_id = pi.id ) as yearly_plans, -- SDG Alignment Details ( SELECT json_agg ( json_build_object ( 'alignment_id', sa.id, 'objective_id', sa.strat_plan_objective_id, 'performance_indicator_id', sa.strat_plan_performance_indicator_id ) ) FROM sdg_alignment sa WHERE sa.strat_plan_objective_id = obj.id ) as sdg_alignments, -- Related OPCR Details (if any) ( SELECT json_agg ( json_build_object ( 'opcr_id', o.id, 'title', o.title, 'review_by', o.review_by, 'reviewer_position', o.reviewer_position ) ) FROM opcr o WHERE o.unit_id = sp.unit_id AND ( o.office_id IS NULL OR o.office_id = sp.office_id ) AND ( o.program_id IS NULL OR o.program_id = sp.program_id ) AND ( EXTRACT( YEAR FROM o.created_at ) BETWEEN sp.start_year AND sp.end_year ) ) as related_opcrs, -- Timestamps sp.created_at, sp.updated_at FROM strategic_plan sp -- Owner joins LEFT JOIN profiles p ON sp.owner_id = p.id LEFT JOIN position pos ON p.position_id = pos.id LEFT JOIN nature_of_work now_type ON p.nature_of_work_id = now_type.id LEFT JOIN employee_status emp_status ON p.employee_status_id = emp_status.id LEFT JOIN unit owner_unit ON p.unit_id = owner_unit.id LEFT JOIN office owner_office ON p.office_id = owner_office.id LEFT JOIN program owner_program ON p.program_id = owner_program.id -- Strategic Plan Organization joins LEFT JOIN unit sp_unit ON sp.unit_id = sp_unit.id LEFT JOIN office sp_office ON sp.office_id = sp_office.id LEFT JOIN program sp_program ON sp.program_id = sp_program.id -- Strategic Plan hierarchy joins LEFT JOIN strat_plan_objective obj ON sp.id = obj.strategic_plan_id LEFT JOIN strategy_plan strat ON sp.id = strat.strat_plan_id LEFT JOIN strategy_plan_performance_indicator pi ON strat.id = pi.strategy_plan_id; -- Grant SELECT permission to authenticated users GRANT SELECT ON strategic_plan_backup_view TO authenticated;
```

# 20250204161122_create_accomplishment_report_backup_view.sql

```sql
CREATE OR REPLACE VIEW accomplishment_report_backup_view AS SELECT ar.id as accomplishment_report_id, ar.title as accomplishment_report_title, ar.implementing_unit, ar.review_by, ar.reviewer_position, ar.approve_by, ar.approver_position, -- Owner details p.id as owner_id, p.employee_id as owner_employee_id, p.first_name as owner_first_name, p.middle_name as owner_middle_name, p.last_name as owner_last_name, p.email as owner_email, pos.name as owner_position_name, now_type.type as owner_nature_of_work, emp_status.type as owner_employee_status, -- Owner organization details owner_unit.id as owner_unit_id, owner_unit.code as owner_unit_code, owner_unit.name as owner_unit_name, owner_office.id as owner_office_id, owner_office.code as owner_office_code, owner_office.name as owner_office_name, owner_program.id as owner_program_id, owner_program.name as owner_program_name, -- AR organization details ar_unit.id as ar_unit_id, ar_unit.code as ar_unit_code, ar_unit.name as ar_unit_name, ar_office.id as ar_office_id, ar_office.code as ar_office_code, ar_office.name as ar_office_name, ar_program.id as ar_program_id, ar_program.name as ar_program_name, -- Hierarchy details h.id as header_id, h.title as header_title, h.position as header_position, ap.id as annual_plan_id, ap.description as annual_plan_description, ap.position as annual_plan_position, -- Activity details act.id as activity_id, act.activity, act.position as activity_position, -- Activity Indicator details act_ind.id as indicator_id, act_ind.input_type, act_ind.performance_indicator, act_ind.annual_target, act_ind.q1_accomplishment, act_ind.q2_accomplishment, act_ind.q3_accomplishment, act_ind.q4_accomplishment, act_ind.total, act_ind.accomplishment_rate, act_ind.responsible_officer_unit, act_ind.remarks as indicator_remarks, act_ind.position as indicator_position, -- Related IPCR indicators ( SELECT json_agg ( json_build_object ( 'indicator_id', i.id, 'final_output', i.final_output, 'success_indicator', i.success_indicator, 'accomplishments', ( SELECT json_agg ( json_build_object ( 'id', ia.id, 'actual_accomplishments', ia.actual_accomplishments, 'quantity', ia.quantity ) ) FROM ipcr_indicator_accomplishment ia WHERE ia.ipcr_indicator_id = i.id ) ) ) FROM ipcr_indicator i WHERE EXISTS ( SELECT 1 FROM ipcr ipcr_parent WHERE get_ipcr_id_from_indicator (i.id) = ipcr_parent.id AND (ar.unit_id = ipcr_parent.unit_id) AND ( ar.office_id IS NULL OR ar.office_id = ipcr_parent.office_id ) AND ( ar.program_id IS NULL OR ar.program_id = ipcr_parent.program_id ) ) ) as related_ipcr_indicators, ar.created_at, ar.updated_at FROM accomplishment_report ar LEFT JOIN profiles p ON ar.owner_id = p.id LEFT JOIN position pos ON p.position_id = pos.id LEFT JOIN nature_of_work now_type ON p.nature_of_work_id = now_type.id LEFT JOIN employee_status emp_status ON p.employee_status_id = emp_status.id LEFT JOIN unit owner_unit ON p.unit_id = owner_unit.id LEFT JOIN office owner_office ON p.office_id = owner_office.id LEFT JOIN program owner_program ON p.program_id = owner_program.id LEFT JOIN unit ar_unit ON ar.unit_id = ar_unit.id LEFT JOIN office ar_office ON ar.office_id = ar_office.id LEFT JOIN program ar_program ON ar.program_id = ar_program.id LEFT JOIN accomplishment_header h ON ar.id = h.accomplishment_report_id LEFT JOIN accomplishment_annual_plan ap ON h.id = ap.accomplishment_header_id LEFT JOIN accomplishment_activity act ON ap.id = act.accomplishment_annual_plan_id LEFT JOIN accomplishment_activity_indicator act_ind ON act.id = act_ind.accomplishment_activity_id; GRANT SELECT ON accomplishment_report_backup_view TO authenticated;
```

# 20250217185209_create_view_op_header_to_indicators.sql

```sql
-- Drop existing view if it exists DROP VIEW IF EXISTS op_header_indicators; -- Create view for op header indicators CREATE OR REPLACE VIEW op_header_indicators AS SELECT h.id AS header_id, h.title AS header_title, h.position AS header_position, ind.id AS indicator_id, ind.input_type, ind.performance_indicator, ind.former_state, ind.q1_target, ind.q2_target, ind.q3_target, ind.q4_target, ind.total, ind.responsible_officer_unit, ind.total_budgetary_requirements, ind.position AS indicator_position, act.id AS activity_id, act.activity, act.position AS activity_position, ap.id AS annual_plan_id, ap.description AS annual_plan_description, ap.position AS annual_plan_position FROM op_header h LEFT JOIN op_annual_plan ap ON h.id = ap.op_header_id LEFT JOIN op_activity act ON ap.id = act.op_annual_plan_id LEFT JOIN op_activity_indicator ind ON act.id = ind.op_activity_id ORDER BY h.position, ap.position, act.position, ind.position; -- Grant select permission to authenticated users GRANT SELECT ON op_header_indicators TO authenticated
```

# 20250219091727_permission_rls_operational_plan.sql

```sql
-- Enable RLS on operational_plan table -- ALTER TABLE operational_plan ENABLE ROW LEVEL SECURITY; -- -- Create policy for read access (authenticated users can read all operational plans) -- CREATE POLICY "Enable read access for authenticated users on operational_plan" ON operational_plan FOR -- SELECT -- TO authenticated USING (true); -- -- Create policy for insert (require create_operational_plan permission) -- CREATE POLICY "Enable insert for users with create permission on operational_plan" ON operational_plan FOR INSERT TO authenticated -- WITH -- CHECK (check_permission ('create_operational_plan')); -- -- Create policy for update (creator or users with edit permission and correct scope) -- CREATE POLICY "Enable update for creator or users with edit permission on operational_plan" ON operational_plan FOR -- UPDATE TO authenticated USING ( -- auth.uid () = creator_id -- OR ( -- check_permission ('edit_operational_plan', unit_id) -- ) -- ) -- WITH -- CHECK ( -- auth.uid () = creator_id -- OR ( -- check_permission ('edit_operational_plan', unit_id) -- ) -- ); -- -- Create policy for delete (only creator) -- CREATE POLICY "Enable delete for creator on operational_plan" ON operational_plan FOR DELETE TO authenticated USING (auth.uid () = creator_id); -- -- Add RLS to related tables (op_header, op_annual_plan, op_activity, op_activity_indicator) -- -- op_header -- ALTER TABLE op_header ENABLE ROW LEVEL SECURITY; -- CREATE POLICY "Enable read access for authenticated users on op_header" ON op_header FOR -- SELECT -- TO authenticated USING (true); -- CREATE POLICY "Enable insert/update/delete through operational_plan policies on op_header" ON op_header FOR ALL TO authenticated USING ( -- EXISTS ( -- SELECT -- 1 -- FROM -- operational_plan op -- WHERE -- op.id = op_header.operational_plan_id -- AND ( -- op.creator_id = auth.uid () -- OR ( -- check_permission ( -- 'edit_operational_plan', -- op.office_id, -- op.unit_id, -- op.program_id -- ) -- ) -- ) -- ) -- ); -- -- op_annual_plan -- ALTER TABLE op_annual_plan ENABLE ROW LEVEL SECURITY; -- CREATE POLICY "Enable read access for authenticated users on op_annual_plan" ON op_annual_plan FOR -- SELECT -- TO authenticated USING (true); -- CREATE POLICY "Enable insert/update/delete through operational_plan policies on op_annual_plan" ON op_annual_plan FOR ALL TO authenticated USING ( -- EXISTS ( -- SELECT -- 1 -- FROM -- operational_plan op -- JOIN op_header h ON h.operational_plan_id = op.id -- WHERE -- h.id = op_annual_plan.op_header_id -- AND ( -- op.creator_id = auth.uid () -- OR ( -- check_permission ( -- 'edit_operational_plan', -- op.office_id, -- op.unit_id, -- op.program_id -- ) -- ) -- ) -- ) -- ); -- -- op_activity -- ALTER TABLE op_activity ENABLE ROW LEVEL SECURITY; -- CREATE POLICY "Enable read access for authenticated users on op_activity" ON op_activity FOR -- SELECT -- TO authenticated USING (true); -- CREATE POLICY "Enable insert/update/delete through operational_plan policies on op_activity" ON op_activity FOR ALL TO authenticated USING ( -- EXISTS ( -- SELECT -- 1 -- FROM -- operational_plan op -- JOIN op_header h ON h.operational_plan_id = op.id -- JOIN op_annual_plan ap ON ap.op_header_id = h.id -- WHERE -- ap.id = op_activity.op_annual_plan_id -- AND ( -- op.creator_id = auth.uid () -- OR ( -- check_permission ( -- 'edit_operational_plan', -- op.office_id, -- op.unit_id, -- op.program_id -- ) -- ) -- ) -- ) -- ); -- -- op_activity_indicator -- ALTER TABLE op_activity_indicator ENABLE ROW LEVEL SECURITY; -- CREATE POLICY "Enable read access for authenticated users on op_activity_indicator" ON op_activity_indicator FOR -- SELECT -- TO authenticated USING (true); -- CREATE POLICY "Enable insert/update/delete through operational_plan policies on op_activity_indicator" ON op_activity_indicator FOR ALL TO authenticated USING ( -- EXISTS ( -- SELECT -- 1 -- FROM -- operational_plan op -- JOIN op_header h ON h.operational_plan_id = op.id -- JOIN op_annual_plan ap ON ap.op_header_id = h.id -- JOIN op_activity a ON a.op_annual_plan_id = ap.id -- WHERE -- a.id = op_activity_indicator.op_activity_id -- AND ( -- op.creator_id = auth.uid () -- OR ( -- check_permission ( -- 'edit_operational_plan', -- op.office_id, -- op.unit_id, -- op.program_id -- ) -- ) -- ) -- ) -- );
```

# 20250220064558_create_op_acc_indicators.sql

```sql
-- Create the table for storing indicator mappings CREATE TABLE op_acc_indicators ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), operational_plan_id UUID NOT NULL REFERENCES operational_plan(id) ON DELETE CASCADE, accomplishment_report_id UUID NOT NULL REFERENCES accomplishment_report(id) ON DELETE CASCADE, op_activity_indicator_id UUID NOT NULL REFERENCES op_activity_indicator(id) ON DELETE CASCADE, accomplishment_activity_indicator_id UUID NOT NULL REFERENCES accomplishment_activity_indicator(id) ON DELETE CASCADE, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Create indexes for better query performance CREATE INDEX idx_op_acc_indicators_op_plan ON op_acc_indicators(operational_plan_id); CREATE INDEX idx_op_acc_indicators_acc_report ON op_acc_indicators(accomplishment_report_id); CREATE INDEX idx_op_acc_indicators_op_indicator ON op_acc_indicators(op_activity_indicator_id); CREATE INDEX idx_op_acc_indicators_acc_indicator ON op_acc_indicators(accomplishment_activity_indicator_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON op_acc_indicators FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at(); -- Grant necessary permissions GRANT SELECT ON op_acc_indicators TO authenticated;
```

# 20250220182331_accomplishment_history.sql

```sql
CREATE TABLE accomplishment_history ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), ipcr_indicator_accomplishment_id UUID NOT NULL, input_value TEXT NOT NULL, quarter INTEGER NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, FOREIGN KEY (ipcr_indicator_accomplishment_id) REFERENCES ipcr_indicator_accomplishment(id) ON DELETE CASCADE ); -- Add indexes CREATE INDEX idx_accomplishment_history_accomplishment_id ON accomplishment_history(ipcr_indicator_accomplishment_id); CREATE INDEX idx_accomplishment_history_created_at ON accomplishment_history(created_at);
```

# 20250221075916_notifications.sql

```sql
-- Create notification_type enum --color scheme: success: green, warning: yellow, fail: red, notification: blue CREATE TYPE notification_type AS ENUM ('success', 'warning', 'fail', 'notification'); -- First drop the existing table DROP TABLE IF EXISTS notifications; -- Recreate notifications table with modified constraints CREATE TABLE notifications ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), sender_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL, receiver_id UUID REFERENCES auth.users(id) ON DELETE CASCADE, type notification_type NOT NULL, title TEXT NOT NULL, message TEXT, is_read BOOLEAN DEFAULT false, is_global BOOLEAN DEFAULT false NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, -- Add constraint to ensure receiver_id is NOT NULL when is_global is false CONSTRAINT check_receiver_id CHECK ( (is_global = true) OR (is_global = false AND receiver_id IS NOT NULL) ) ); -- Recreate indexes CREATE INDEX idx_notifications_receiver_id ON notifications(receiver_id); CREATE INDEX idx_notifications_sender_id ON notifications(sender_id); CREATE INDEX idx_notifications_created_at ON notifications(created_at); CREATE INDEX idx_notifications_is_global ON notifications(is_global); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON notifications FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at(); -- Enable RLS ALTER TABLE notifications ENABLE ROW LEVEL SECURITY; -- Recreate RLS policies with updated logic CREATE POLICY "Users can read their notifications or global notifications" ON notifications FOR SELECT TO authenticated USING ( (is_global = true) OR (auth.uid() = receiver_id) ); CREATE POLICY "Users can create notifications" ON notifications FOR INSERT TO authenticated WITH CHECK ( auth.uid() = sender_id AND ( (NOT is_global AND receiver_id IS NOT NULL) OR (is_global AND check_permission('send_global_notifications')) ) ); CREATE POLICY "Users can update their received notifications" ON notifications FOR UPDATE TO authenticated USING ( auth.uid() = receiver_id AND NOT is_global ); -- Enable realtime ALTER PUBLICATION supabase_realtime ADD TABLE notifications;
```

# 20250222163427_create_ipcr_immediate_reviewer.sql

```sql
-- Create enum type for supervisor status CREATE TYPE ipcr_supervisor_status AS ENUM ( 'under_review_raw', 'revision_raw', 'reviewed_raw', 'under_review', 'revision', 'approved' ); -- Create table for IPCR immediate supervisors CREATE TABLE ipcr_immediate_supervisor ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), supervisor_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL, ipcr_id UUID REFERENCES ipcr(id) ON DELETE CASCADE NOT NULL, status ipcr_supervisor_status, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, UNIQUE(supervisor_id, ipcr_id) ); -- Create indexes for better query performance CREATE INDEX idx_ipcr_immediate_supervisor_ipcr_id ON ipcr_immediate_supervisor(ipcr_id); CREATE INDEX idx_ipcr_immediate_supervisor_supervisor_id ON ipcr_immediate_supervisor(supervisor_id); CREATE INDEX idx_ipcr_immediate_supervisor_status ON ipcr_immediate_supervisor(status); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON ipcr_immediate_supervisor FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20250222190142_create_supervisor_data.sql

```sql
-- Drop the existing function DROP FUNCTION IF EXISTS create_supervisor_data(UUID); -- Create the updated function that returns added supervisor IDs CREATE OR REPLACE FUNCTION create_supervisor_data(p_ipcr_id UUID) RETURNS TABLE ( supervisor_id UUID, ipcr_id UUID, created_at TIMESTAMP WITH TIME ZONE ) LANGUAGE plpgsql SECURITY DEFINER AS $$ DECLARE temp_supervisors UUID[]; BEGIN -- Create temporary table to store results CREATE TEMP TABLE temp_results ( supervisor_id UUID, ipcr_id UUID, created_at TIMESTAMP WITH TIME ZONE ) ON COMMIT DROP; -- Insert supervisors from ipcr_indicator and capture IDs WITH inserted AS ( INSERT INTO ipcr_immediate_supervisor (supervisor_id, ipcr_id, created_at, updated_at) SELECT DISTINCT i.immediate_supervisor_id, f.ipcr_id, f.created_at, f.updated_at FROM ipcr_indicator i JOIN ipcr_function f ON i.ipcr_function_id = f.id JOIN ipcr ON f.ipcr_id = ipcr.id WHERE i.immediate_supervisor_id IS NOT NULL AND ipcr.status = 'submitted_raw' AND f.ipcr_id = p_ipcr_id AND NOT EXISTS ( SELECT 1 FROM ipcr_immediate_supervisor s WHERE s.supervisor_id = i.immediate_supervisor_id AND s.ipcr_id = f.ipcr_id ) RETURNING ipcr_immediate_supervisor.supervisor_id, ipcr_immediate_supervisor.ipcr_id, ipcr_immediate_supervisor.created_at ) INSERT INTO temp_results SELECT * FROM inserted; -- Insert supervisors from ipcr_function_category and capture IDs WITH inserted AS ( INSERT INTO ipcr_immediate_supervisor (supervisor_id, ipcr_id, created_at, updated_at) SELECT DISTINCT fc.immediate_supervisor_id, f.ipcr_id, f.created_at, f.updated_at FROM ipcr_function_category fc JOIN ipcr_function f ON fc.ipcr_function_id = f.id JOIN ipcr ON f.ipcr_id = ipcr.id WHERE fc.immediate_supervisor_id IS NOT NULL AND ipcr.status = 'submitted_raw' AND f.ipcr_id = p_ipcr_id AND NOT EXISTS ( SELECT 1 FROM ipcr_immediate_supervisor s WHERE s.supervisor_id = fc.immediate_supervisor_id AND s.ipcr_id = f.ipcr_id ) RETURNING ipcr_immediate_supervisor.supervisor_id, ipcr_immediate_supervisor.ipcr_id, ipcr_immediate_supervisor.created_at ) INSERT INTO temp_results SELECT * FROM inserted; -- Return all collected results RETURN QUERY SELECT DISTINCT tr.supervisor_id, tr.ipcr_id, tr.created_at FROM temp_results tr; END; $$; -- Grant necessary permissions GRANT EXECUTE ON FUNCTION create_supervisor_data(UUID) TO authenticated;
```

# 20250223064337_ipcr_consensus_functions.sql

```sql
-- Helper function to check if status requires consensus CREATE OR REPLACE FUNCTION is_consensus_required_status(p_status ipcr_supervisor_status) RETURNS BOOLEAN AS $$ BEGIN RETURN p_status IN ('revision_raw', 'reviewed_raw', 'revision'); END; $$ LANGUAGE plpgsql IMMUTABLE; -- Helper function to check if status requires immediate sync CREATE OR REPLACE FUNCTION is_immediate_sync_status(p_status ipcr_supervisor_status) RETURNS BOOLEAN AS $$ BEGIN RETURN p_status IN ('under_review_raw', 'under_review'); END; $$ LANGUAGE plpgsql IMMUTABLE; -- Function to get the appropriate status based on supervisor statuses CREATE OR REPLACE FUNCTION get_supervisor_consensus_status(p_ipcr_id UUID) RETURNS ipcr_supervisor_status AS $$ DECLARE v_consensus_status ipcr_supervisor_status; v_supervisor_count INTEGER; v_has_consensus BOOLEAN; v_current_status ipcr_status; BEGIN -- Get current IPCR status SELECT status INTO v_current_status FROM ipcr WHERE id = p_ipcr_id; -- Get total number of supervisors SELECT COUNT(*) INTO v_supervisor_count FROM ipcr_immediate_supervisor WHERE ipcr_id = p_ipcr_id; -- Return NULL if no supervisors IF v_supervisor_count = 0 THEN RETURN NULL; END IF; -- First check for immediate sync statuses (any supervisor triggers change) SELECT status INTO v_consensus_status FROM ipcr_immediate_supervisor WHERE ipcr_id = p_ipcr_id AND is_immediate_sync_status(status) LIMIT 1; IF v_consensus_status IS NOT NULL THEN RETURN v_consensus_status; END IF; -- Check for approved status (requires all supervisors) SELECT COUNT(*) = v_supervisor_count INTO v_has_consensus FROM ipcr_immediate_supervisor WHERE ipcr_id = p_ipcr_id AND status = 'approved'; IF v_has_consensus THEN RETURN 'approved'; END IF; -- Check consensus for action-required statuses FOR v_consensus_status IN SELECT unnest(enum_range(NULL::ipcr_supervisor_status)) LOOP -- Skip if status doesn't require consensus CONTINUE WHEN NOT is_consensus_required_status(v_consensus_status); -- Check if all supervisors have this status SELECT COUNT(*) = v_supervisor_count INTO v_has_consensus FROM ipcr_immediate_supervisor WHERE ipcr_id = p_ipcr_id AND status = v_consensus_status; IF v_has_consensus THEN RETURN v_consensus_status; END IF; END LOOP; -- For reviewed_raw specifically, maintain revision_raw until all supervisors reach reviewed_raw IF v_current_status = 'revision_raw'::ipcr_status THEN SELECT COUNT(*) = v_supervisor_count INTO v_has_consensus FROM ipcr_immediate_supervisor WHERE ipcr_id = p_ipcr_id AND status = 'reviewed_raw'; IF NOT v_has_consensus THEN RETURN 'revision_raw'; END IF; END IF; -- Return NULL to indicate no status change needed RETURN NULL; END; $$ LANGUAGE plpgsql SECURITY DEFINER; -- Function to sync IPCR status CREATE OR REPLACE FUNCTION sync_ipcr_status(p_ipcr_id UUID) RETURNS void AS $$ DECLARE v_consensus_status ipcr_supervisor_status; v_current_ipcr_status ipcr_status; BEGIN -- Get current IPCR status SELECT status INTO v_current_ipcr_status FROM ipcr WHERE id = p_ipcr_id; -- Get consensus status if applicable v_consensus_status := get_supervisor_consensus_status(p_ipcr_id); -- Update IPCR status if we have a new status to apply IF v_consensus_status IS NOT NULL THEN UPDATE ipcr SET status = CASE -- Action-required statuses WHEN v_consensus_status = 'revision_raw' THEN 'revision_raw'::ipcr_status WHEN v_consensus_status = 'reviewed_raw' THEN 'reviewed_raw'::ipcr_status WHEN v_consensus_status = 'revision' THEN 'revision'::ipcr_status -- Immediate sync statuses WHEN v_consensus_status = 'under_review_raw' THEN 'under_review_raw'::ipcr_status WHEN v_consensus_status = 'under_review' THEN 'under_review'::ipcr_status -- Approved status (requires all) WHEN v_consensus_status = 'approved' THEN 'approved'::ipcr_status ELSE v_current_ipcr_status END WHERE id = p_ipcr_id; END IF; END; $$ LANGUAGE plpgsql SECURITY DEFINER; -- Grant necessary permissions GRANT EXECUTE ON FUNCTION is_consensus_required_status(ipcr_supervisor_status) TO authenticated; GRANT EXECUTE ON FUNCTION is_immediate_sync_status(ipcr_supervisor_status) TO authenticated; GRANT EXECUTE ON FUNCTION get_supervisor_consensus_status(UUID) TO authenticated; GRANT EXECUTE ON FUNCTION sync_ipcr_status(UUID) TO authenticated;
```

# 20250223064409_ipcr_consensus_trigger.sql

```sql
-- Create trigger function for status synchronization CREATE OR REPLACE FUNCTION trigger_sync_ipcr_status() RETURNS TRIGGER AS $$ BEGIN IF (TG_OP = 'UPDATE' AND OLD.status IS DISTINCT FROM NEW.status) OR (TG_OP = 'INSERT') OR (TG_OP = 'DELETE') THEN PERFORM sync_ipcr_status(COALESCE(NEW.ipcr_id, OLD.ipcr_id)); END IF; RETURN NEW; END; $$ LANGUAGE plpgsql SECURITY DEFINER; -- Create or replace the trigger DROP TRIGGER IF EXISTS sync_ipcr_status_trigger ON ipcr_immediate_supervisor; CREATE TRIGGER sync_ipcr_status_trigger AFTER INSERT OR UPDATE OR DELETE ON ipcr_immediate_supervisor FOR EACH ROW EXECUTE FUNCTION trigger_sync_ipcr_status();
```

# 20250223064545_view_for_debugging.sql

```sql
-- Enhanced view for monitoring status and consensus CREATE OR REPLACE VIEW ipcr_supervisor_status_view AS WITH supervisor_statuses AS ( SELECT s.ipcr_id, s.status, s.supervisor_id, p.first_name, p.last_name, is_consensus_required_status(s.status::ipcr_supervisor_status) as requires_consensus FROM ipcr_immediate_supervisor s LEFT JOIN profiles p ON s.supervisor_id = p.id ) SELECT i.id as ipcr_id, i.status as ipcr_status, CASE WHEN COUNT(ss.supervisor_id) = 0 THEN 'No supervisors assigned' WHEN COUNT(DISTINCT ss.status) = 1 AND bool_and(ss.requires_consensus) THEN 'All supervisors agree on action-required status' WHEN COUNT(DISTINCT ss.status) = 1 THEN 'All supervisors agree (no action required)' ELSE 'Supervisors have different statuses' END as consensus_status, COUNT(ss.supervisor_id) as total_supervisors, COUNT(DISTINCT ss.status) as unique_statuses, bool_or(ss.requires_consensus) as has_action_required_status, json_agg( CASE WHEN ss.supervisor_id IS NOT NULL THEN json_build_object( 'supervisor_id', ss.supervisor_id, 'status', ss.status, 'name', ss.first_name || ' ' || ss.last_name, 'requires_consensus', ss.requires_consensus ) ELSE NULL END ) FILTER (WHERE ss.supervisor_id IS NOT NULL) as supervisors FROM ipcr i LEFT JOIN supervisor_statuses ss ON i.id = ss.ipcr_id GROUP BY i.id, i.status; -- Grant necessary permissions GRANT SELECT ON ipcr_supervisor_status_view TO authenticated;
```

# 20250223134206_ipcr_supervisor_details_view.sql

```sql
CREATE OR REPLACE VIEW ipcr_supervisor_details_view AS SELECT -- IPCR Supervisor relationship details is_sup.id as supervisor_relationship_id, is_sup.status as supervisor_review_status, is_sup.created_at as supervisor_assignment_date, -- IPCR basic details i.id as ipcr_id, i.title as ipcr_title, i.status as ipcr_status, -- IPCR Owner details i.owner_id, CONCAT ( owner_profile.first_name, CASE WHEN owner_profile.middle_name IS NOT NULL AND owner_profile.middle_name != '' THEN ' ' || owner_profile.middle_name || ' ' ELSE ' ' END, owner_profile.last_name ) as owner_full_name, owner_profile.employee_id as owner_employee_id, owner_profile.email as owner_email, -- Owner's position and status owner_pos.name as owner_position, owner_now.type as owner_nature_of_work, owner_emp_status.type as owner_employment_status, -- Owner's organizational details owner_unit.code as owner_unit_code, owner_unit.name as owner_unit_name, owner_office.code as owner_office_code, owner_office.name as owner_office_name, owner_program.name as owner_program_name, -- Supervisor details is_sup.supervisor_id, CONCAT ( sup_profile.first_name, CASE WHEN sup_profile.middle_name IS NOT NULL AND sup_profile.middle_name != '' THEN ' ' || sup_profile.middle_name || ' ' ELSE ' ' END, sup_profile.last_name ) as supervisor_full_name, sup_profile.employee_id as supervisor_employee_id, sup_profile.email as supervisor_email, sup_pos.name as supervisor_position, -- IPCR review hierarchy details i.immediate_supervisor as designated_supervisor_name, i.immediate_supervisor_position as designated_supervisor_position, i.program_chair, i.dean FROM ipcr_immediate_supervisor is_sup JOIN ipcr i ON i.id = is_sup.ipcr_id -- Owner joins LEFT JOIN profiles owner_profile ON i.owner_id = owner_profile.id LEFT JOIN position owner_pos ON owner_profile.position_id = owner_pos.id LEFT JOIN nature_of_work owner_now ON owner_profile.nature_of_work_id = owner_now.id LEFT JOIN employee_status owner_emp_status ON owner_profile.employee_status_id = owner_emp_status.id LEFT JOIN unit owner_unit ON owner_profile.unit_id = owner_unit.id LEFT JOIN office owner_office ON owner_profile.office_id = owner_office.id LEFT JOIN program owner_program ON owner_profile.program_id = owner_program.id -- Supervisor joins LEFT JOIN profiles sup_profile ON is_sup.supervisor_id = sup_profile.id LEFT JOIN position sup_pos ON sup_profile.position_id = sup_pos.id; -- Grant necessary permissions GRANT SELECT ON ipcr_supervisor_details_view TO authenticated;
```

