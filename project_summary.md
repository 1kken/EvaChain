# 20241116152556_create_table_unit.sql

```sql
-- Create the function for updating timestamps CREATE OR REPLACE FUNCTION fn_set_updated_at() RETURNS TRIGGER AS $$ BEGIN NEW.updated_at = TIMEZONE('utc'::text, NOW()); RETURN NEW; END; $$ LANGUAGE plpgsql; -- Create the unit table CREATE TABLE unit ( id INTEGER GENERATED BY DEFAULT AS IDENTITY NOT NULL PRIMARY KEY, code VARCHAR(50) NOT NULL UNIQUE, name TEXT NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Create index on commonly searched columns CREATE INDEX idx_unit_code ON unit(code); -- Add updated_at trigger CREATE TRIGGER set_updated_at BEFORE UPDATE ON unit FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241116153626_create_table_nature_of_work.sql

```sql
-- create table CREATE TABLE nature_of_work ( id INTEGER GENERATED BY DEFAULT AS IDENTITY NOT NULL PRIMARY KEY, type VARCHAR(100) NOT NULL UNIQUE, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Add updated_at trigger CREATE TRIGGER set_updated_at BEFORE UPDATE ON nature_of_work FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241116155829_create_table_office.sql

```sql
CREATE TABLE office ( id INTEGER GENERATED BY DEFAULT AS IDENTITY NOT NULL PRIMARY KEY, unit_id INTEGER NOT NULL REFERENCES unit(id), code VARCHAR(50) NOT NULL UNIQUE, name VARCHAR(200) NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Create index for foreign key CREATE INDEX idx_office_unit_id ON office(unit_id); -- Add updated_at trigger CREATE TRIGGER set_updated_at BEFORE UPDATE ON office FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241116160732_create_table_program.sql

```sql
CREATE TABLE program ( id INTEGER GENERATED BY DEFAULT AS IDENTITY NOT NULL PRIMARY KEY, unit_id INTEGER NOT NULL REFERENCES unit(id), office_id INTEGER NOT NULL REFERENCES office(id), name TEXT NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Create indexes for foreign keys CREATE INDEX idx_program_unit_id ON program(unit_id); CREATE INDEX idx_program_office_id ON program(office_id); -- Add updated_at trigger CREATE TRIGGER set_updated_at BEFORE UPDATE ON program FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241116161506_create_table_position.sql

```sql
CREATE TABLE position ( id INTEGER GENERATED BY DEFAULT AS IDENTITY NOT NULL PRIMARY KEY, nature_of_work_id INTEGER NOT NULL REFERENCES nature_of_work(id), name VARCHAR(100) NOT NULL UNIQUE, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Create index for foreign key CREATE INDEX idx_position_nature_of_work_id ON position(nature_of_work_id); -- Add updated_at trigger CREATE TRIGGER set_updated_at BEFORE UPDATE ON position FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241116161733_create_table_employee_status.sql

```sql
-- create table CREATE TABLE employee_status ( id INTEGER GENERATED BY DEFAULT AS IDENTITY NOT NULL PRIMARY KEY, type VARCHAR(100) NOT NULL UNIQUE, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Add updated_at trigger CREATE TRIGGER set_updated_at BEFORE UPDATE ON employee_status FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241116162523_create_table_profile.sql

```sql
-- Create a table for public profiles create table profiles ( id uuid references auth.users on delete cascade not null primary key, updated_at timestamp with time zone default timezone('utc'::text, now()), employee_id varchar(50) unique, email varchar(255) unique, first_name text, middle_name text, last_name text, avatar_url text, unit_id integer references unit(id), nature_of_work_id integer references nature_of_work(id), office_id integer references office(id), program_id integer references program(id), position_id integer references position(id), employee_status_id integer references employee_status(id), created_at timestamp with time zone default timezone('utc'::text, now()) ); -- Set up Row Level Security (RLS) alter table profiles enable row level security; create policy "Public profiles are viewable by everyone." on profiles for select using (true); create policy "Users can insert their own profile." on profiles for insert with check ((select auth.uid()) = id); create policy "Users can update own profile." on profiles for update using ((select auth.uid()) = id); -- Create function to handle new user signup with Google OAuth data create function public.handle_new_user() returns trigger language plpgsql security definer set search_path = public as $$ begin insert into public.profiles ( id, email, first_name, last_name, avatar_url ) values ( new.id, new.email, coalesce( new.raw_user_meta_data->>'first_name', new.raw_user_meta_data->>'given_name', split_part(new.raw_user_meta_data->>'full_name', ' ', 1), 'Anonymous' ), coalesce( new.raw_user_meta_data->>'last_name', new.raw_user_meta_data->>'family_name', array_to_string( array_remove( string_to_array(new.raw_user_meta_data->>'full_name', ' '), split_part(new.raw_user_meta_data->>'full_name', ' ', 1) ), ' ' ), 'User' ), coalesce( new.raw_user_meta_data->>'avatar_url', new.raw_user_meta_data->>'picture', new.raw_user_meta_data->>'avatar', null ) ); return new; exception when others then raise log 'Error in handle_new_user: %', SQLERRM; return new; -- Still return the user even if profile creation fails end; $$; -- Create trigger for new user signup create trigger on_auth_user_created after insert on auth.users for each row execute procedure public.handle_new_user(); -- Set up Storage! insert into storage.buckets (id, name, public) values ('avatars', 'avatars',true); -- Set up access controls for storage. -- See https://supabase.com/docs/guides/storage#policy-examples for more details. create policy "Avatar images are publicly accessible." on storage.objects for select using (bucket_id = 'avatars'); create policy "Anyone can upload an avatar." on storage.objects for insert with check (bucket_id = 'avatars'); -- Allow users to upload their own avatar create policy "Users can update their own avatar" on storage.objects for update to authenticated using ( bucket_id = 'avatars' and auth.uid()::text = (storage.foldername(name))[1] ); -- Add updated_at trigger CREATE TRIGGER set_updated_at BEFORE UPDATE ON profiles FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241122141115_add_cascade_on_delete.sql

```sql
-- First, drop existing foreign key constraints ALTER TABLE office DROP CONSTRAINT office_unit_id_fkey; ALTER TABLE program DROP CONSTRAINT program_unit_id_fkey; ALTER TABLE program DROP CONSTRAINT program_office_id_fkey; ALTER TABLE position DROP CONSTRAINT position_nature_of_work_id_fkey; -- Then add them back with ON DELETE CASCADE ALTER TABLE office ADD CONSTRAINT office_unit_id_fkey FOREIGN KEY (unit_id) REFERENCES unit(id) ON DELETE CASCADE; ALTER TABLE program ADD CONSTRAINT program_unit_id_fkey FOREIGN KEY (unit_id) REFERENCES unit(id) ON DELETE CASCADE; ALTER TABLE program ADD CONSTRAINT program_office_id_fkey FOREIGN KEY (office_id) REFERENCES office(id) ON DELETE CASCADE; ALTER TABLE position ADD CONSTRAINT position_nature_of_work_id_fkey FOREIGN KEY (nature_of_work_id) REFERENCES nature_of_work(id) ON DELETE CASCADE;
```

# 20241122170218_add_realtime_tables.sql

```sql
-- alter publication supabase_realtime -- add table unit, -- nature_of_work, -- office, -- program, -- position, -- employee_status, -- profiles;
```

# 20241127102744_scope_type.sql

```sql
-- Create scope type CREATE TYPE scope_type AS ENUM ('all', 'office','program', 'unit');
```

# 20241127115411_create_roles_table.sql

```sql
-- Roles table CREATE TABLE roles ( id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, name VARCHAR(100) NOT NULL UNIQUE, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL );
```

# 20241127120413_create_permissions_table.sql

```sql
-- Permissions table CREATE TABLE permissions ( id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, name VARCHAR(100) NOT NULL UNIQUE, description TEXT, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL );
```

# 20241127121741_create_role_permissions_table.sql

```sql
-- Role permissions mapping with scope CREATE TABLE role_permissions ( id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, role_id INTEGER REFERENCES roles(id) ON DELETE CASCADE, permission_id INTEGER REFERENCES permissions(id) ON DELETE CASCADE, scope scope_type NOT NULL DEFAULT 'unit', created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, UNIQUE(role_id, permission_id) );
```

# 20241127121931_create_user_roles_table.sql

```sql
-- User roles mapping (one role per user) CREATE TABLE user_roles ( id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE, role_id INTEGER NOT NULL REFERENCES roles(id) ON DELETE CASCADE, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, UNIQUE(user_id) );
```

# 20241127123124_create_auth_jwt_function.sql

```sql
-- Grant necessary permissions GRANT USAGE ON SCHEMA auth TO postgres, authenticated, anon; GRANT SELECT ON TABLE user_roles TO supabase_auth_admin; GRANT SELECT ON TABLE roles TO supabase_auth_admin; GRANT EXECUTE ON FUNCTION auth.jwt() TO postgres, authenticated, anon; -- Create the JWT function CREATE OR REPLACE FUNCTION auth.jwt() RETURNS jsonb LANGUAGE plpgsql SECURITY DEFINER SET search_path = auth, public AS $$ DECLARE result jsonb; BEGIN SELECT jsonb_build_object( 'role', roles.name, 'role_id', roles.id ) INTO result FROM user_roles JOIN roles ON user_roles.role_id = roles.id WHERE user_roles.user_id = auth.uid(); RETURN COALESCE(result, '{}'::jsonb); END; $$;
```

# 20241127123317_create_permission_check_function.sql

```sql
CREATE OR REPLACE FUNCTION check_permission( required_permission VARCHAR, target_office_id INTEGER DEFAULT NULL, target_unit_id INTEGER DEFAULT NULL, target_program_id INTEGER DEFAULT NULL ) RETURNS BOOLEAN AS $$ DECLARE user_permission_scope scope_type; user_assigned_office_id INTEGER; user_assigned_unit_id INTEGER; user_assigned_program_id INTEGER; permission_exists BOOLEAN; BEGIN -- Get user's scope and IDs SELECT role_permission.scope, profile.office_id, profile.unit_id, profile.program_id, EXISTS ( SELECT 1 FROM role_permissions role_permission_check JOIN permissions permission ON permission.id = role_permission_check.permission_id WHERE role_permission_check.role_id = (auth.jwt()->>'role_id')::integer AND permission.name = required_permission ) INTO user_permission_scope, user_assigned_office_id, user_assigned_unit_id, user_assigned_program_id, permission_exists FROM profiles profile JOIN user_roles user_role ON profile.id = user_role.user_id JOIN role_permissions role_permission ON user_role.role_id = role_permission.role_id JOIN permissions permission ON role_permission.permission_id = permission.id WHERE profile.id = auth.uid() AND permission.name = required_permission; -- No permission found IF NOT permission_exists THEN RETURN FALSE; END IF; -- Check scope access from highest (all) to lowest (unit) RETURN CASE -- All level (highest scope) WHEN user_permission_scope = 'all' THEN TRUE -- Program level WHEN user_permission_scope = 'program' THEN target_program_id IS NULL OR target_program_id = user_assigned_program_id -- Office level WHEN user_permission_scope = 'office' THEN target_office_id IS NULL OR target_office_id = user_assigned_office_id -- Unit level (lowest scope) WHEN user_permission_scope = 'unit' THEN target_unit_id IS NULL OR target_unit_id = user_assigned_unit_id -- Default case ELSE FALSE END; END; $$ LANGUAGE plpgsql SECURITY DEFINER;
```

# 20241127152010_create_user_role_view.sql

```sql
CREATE VIEW user_role_view AS SELECT user_roles.user_id, roles.name as role_name, roles.id as role_id FROM user_roles JOIN roles ON user_roles.role_id = roles.id; CREATE OR REPLACE FUNCTION get_user_role() RETURNS TABLE ( role_name VARCHAR, role_id INTEGER ) LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$ BEGIN RETURN QUERY SELECT roles.name, roles.id FROM user_roles JOIN roles ON user_roles.role_id = roles.id WHERE user_roles.user_id = auth.uid(); END; $$; -- Grant execute permission GRANT EXECUTE ON FUNCTION get_user_role() TO authenticated;
```

# 20241128090943_system_admin_create_insert_function.sql

```sql
-- Create function to check if user is system admin CREATE OR REPLACE FUNCTION is_system_admin() RETURNS BOOLEAN LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$ DECLARE user_role_name VARCHAR; BEGIN -- Get the role name from the JWT SELECT (auth.jwt()->>'role')::VARCHAR INTO user_role_name; -- Check if user has system_admin role RETURN user_role_name = 'system_admin'; END; $$; -- Grant execute permission GRANT EXECUTE ON FUNCTION is_system_admin() TO authenticated;
```

# 20241128091037_RLS_for_unit.sql

```sql
-- Apply RLS policies to each table ALTER TABLE unit ENABLE ROW LEVEL SECURITY; CREATE POLICY "Enable read access for all users on unit" ON unit FOR SELECT TO authenticated USING (true); CREATE POLICY "Enable insert for system admin on unit" ON unit FOR INSERT TO authenticated WITH CHECK (is_system_admin()); CREATE POLICY "Enable update for system admin on unit" ON unit FOR UPDATE TO authenticated USING (is_system_admin()) WITH CHECK (is_system_admin()); CREATE POLICY "Enable delete for system admin on unit" ON unit FOR DELETE TO authenticated USING (is_system_admin());
```

# 20241128091124_RLS_for_office.sql

```sql
ALTER TABLE office ENABLE ROW LEVEL SECURITY; -- Create policies for office table CREATE POLICY "Enable read access for all users on office" ON office FOR SELECT TO authenticated USING (true); CREATE POLICY "Enable insert for system admin on office" ON office FOR INSERT TO authenticated WITH CHECK (is_system_admin()); CREATE POLICY "Enable update for system admin on office" ON office FOR UPDATE TO authenticated USING (is_system_admin()) WITH CHECK (is_system_admin()); CREATE POLICY "Enable delete for system admin on office" ON office FOR DELETE TO authenticated USING (is_system_admin());
```

# 20241128091158_RLS_for_program.sql

```sql
ALTER TABLE program ENABLE ROW LEVEL SECURITY; -- Create policies for program table CREATE POLICY "Enable read access for all users on program" ON program FOR SELECT TO authenticated USING (true); CREATE POLICY "Enable insert for system admin on program" ON program FOR INSERT TO authenticated WITH CHECK (is_system_admin()); CREATE POLICY "Enable update for system admin on program" ON program FOR UPDATE TO authenticated USING (is_system_admin()) WITH CHECK (is_system_admin()); CREATE POLICY "Enable delete for system admin on program" ON program FOR DELETE TO authenticated USING (is_system_admin());
```

# 20241128091248_RLS_for_nature_of_work.sql

```sql
ALTER TABLE nature_of_work ENABLE ROW LEVEL SECURITY; -- Create policies for nature_of_work table CREATE POLICY "Enable read access for all users on nature_of_work" ON nature_of_work FOR SELECT TO authenticated USING (true); CREATE POLICY "Enable insert for system admin on nature_of_work" ON nature_of_work FOR INSERT TO authenticated WITH CHECK (is_system_admin()); CREATE POLICY "Enable update for system admin on nature_of_work" ON nature_of_work FOR UPDATE TO authenticated USING (is_system_admin()) WITH CHECK (is_system_admin()); CREATE POLICY "Enable delete for system admin on nature_of_work" ON nature_of_work FOR DELETE TO authenticated USING (is_system_admin());
```

# 20241128091505_RLS_for_position.sql

```sql
ALTER TABLE position ENABLE ROW LEVEL SECURITY; -- Create policies for position table CREATE POLICY "Enable read access for all users on position" ON position FOR SELECT TO authenticated USING (true); CREATE POLICY "Enable insert for system admin on position" ON position FOR INSERT TO authenticated WITH CHECK (is_system_admin()); CREATE POLICY "Enable update for system admin on position" ON position FOR UPDATE TO authenticated USING (is_system_admin()) WITH CHECK (is_system_admin()); CREATE POLICY "Enable delete for system admin on position" ON position FOR DELETE TO authenticated USING (is_system_admin());
```

# 20241128091542_RLS_for_employee_status.sql

```sql
ALTER TABLE employee_status ENABLE ROW LEVEL SECURITY; CREATE POLICY "Enable read access for all users on employee_status" ON employee_status FOR SELECT TO authenticated USING (true); CREATE POLICY "Enable insert for system admin on employee_status" ON employee_status FOR INSERT TO authenticated WITH CHECK (is_system_admin()); CREATE POLICY "Enable update for system admin on employee_status" ON employee_status FOR UPDATE TO authenticated USING (is_system_admin()) WITH CHECK (is_system_admin()); CREATE POLICY "Enable delete for system admin on employee_status" ON employee_status FOR DELETE TO authenticated USING (is_system_admin());
```

# 20241216163511_create_table_operational_plan.sql

```sql
-- Create operational_plan table CREATE TABLE operational_plan ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), creator_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL, unit_id INTEGER REFERENCES unit(id) ON DELETE CASCADE NOT NULL, office_id INTEGER REFERENCES office(id) ON DELETE CASCADE, program_id INTEGER REFERENCES program(id) ON DELETE CASCADE, title TEXT NOT NULL, implementing_unit TEXT NOT NULL, review_by VARCHAR(255) NOT NULL, reviewer_position VARCHAR(255) NOT NULL, approve_by VARCHAR(255) NOT NULL, approver_position VARCHAR(255) NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Create indexes for foreign keys and commonly searched fields CREATE INDEX idx_operational_plan_unit_id ON operational_plan(unit_id); CREATE INDEX idx_operational_plan_office_id ON operational_plan(office_id); CREATE INDEX idx_operational_plan_program_id ON operational_plan(program_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON operational_plan FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241218095055_create_op_header_table.sql

```sql
-- Create op_header table CREATE TABLE op_header ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), operational_plan_id UUID REFERENCES operational_plan(id) ON DELETE CASCADE NOT NULL, position INTEGER NOT NULL, title TEXT NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Add indexes for better query performance CREATE INDEX idx_op_header_operational_plan_id ON op_header(operational_plan_id); CREATE INDEX idx_op_header_position ON op_header(position, operational_plan_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON op_header FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241218095410_create_op_annual_plan.sql

```sql
-- Create annual_plan table CREATE TABLE op_annual_plan ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), op_header_id UUID REFERENCES op_header(id) ON DELETE CASCADE NOT NULL, description TEXT NOT NULL, position INTEGER NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Add indexes for better query performance CREATE INDEX idx_op_annual_plan_op_header_id ON op_annual_plan(op_header_id); CREATE INDEX idx_op_annual_plan_position ON op_annual_plan(position, op_header_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON op_annual_plan FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241221025054_create_op_activities_table.sql

```sql
-- Create input type enum CREATE TYPE input_type_op AS ENUM ('percentage', 'number', 'ratio', 'text'); -- Create activities table CREATE TABLE op_activity ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), op_annual_plan_id UUID REFERENCES op_annual_plan(id) ON DELETE CASCADE NOT NULL, activity TEXT NOT NULL, input_type input_type_op NOT NULL DEFAULT 'text', performance_indicator TEXT NOT NULL, former_state TEXT NOT NULL, q1_target TEXT, q2_target TEXT, q3_target TEXT, q4_target TEXT, total TEXT, responsible_officer_unit TEXT NOT NULL, total_budgetary_requirements TEXT NOT NULL, position INTEGER NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Add indexes for better query performance CREATE INDEX idx_op_activity_annual_plan_id ON op_activity(op_annual_plan_id); CREATE INDEX idx_op_activity_position ON op_activity(position, op_annual_plan_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON op_activity FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241223034318_create_ipcr_table.sql

```sql
-- Create status enum type if it doesn't exist already CREATE TYPE ipcr_status AS ENUM ('draft', 'submitted', 'reviewing', 'revision', 'approved'); -- Create ipcr table CREATE TABLE ipcr ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), title VARCHAR(255) NOT NULL, status ipcr_status DEFAULT 'draft' NOT NULL, head_of_operating_unit VARCHAR(255), immediate_supervisor VARCHAR(255), immediate_supervisor_position VARCHAR(255), program_chair VARCHAR(255), dean VARCHAR(255), owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE, unit_id INTEGER REFERENCES unit(id) ON DELETE CASCADE, office_id INTEGER REFERENCES office(id) ON DELETE CASCADE, program_id INTEGER REFERENCES program(id) ON DELETE CASCADE, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Create indexes for foreign keys and common query patterns CREATE INDEX idx_ipcr_owner ON ipcr(owner_id); CREATE INDEX idx_ipcr_unit ON ipcr(unit_id); CREATE INDEX idx_ipcr_office ON ipcr(office_id); CREATE INDEX idx_ipcr_program ON ipcr(program_id); CREATE INDEX idx_ipcr_status ON ipcr(status); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON ipcr FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241223075628_create_ipcr_function_table.sql

```sql
-- Create ipcr_function table CREATE TABLE ipcr_function ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), title VARCHAR(255) NOT NULL, percentage integer NOT NULL, ipcr_id UUID REFERENCES ipcr(id) ON DELETE CASCADE NOT NULL, position INTEGER NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, UNIQUE(ipcr_id, title) ); -- Add index for better query performance when ordering by position CREATE INDEX idx_ipcr_function_position ON ipcr_function(position, ipcr_id); -- Add index for foreign key CREATE INDEX idx_ipcr_function_ipcr_id ON ipcr_function(ipcr_id); -- Add trigger for updating the updated_at timestamp CREATE TRIGGER set_updated_at BEFORE UPDATE ON ipcr_function FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241223175944_create_ipcr_category_table.sql

```sql
-- Create ipcr_function_category table CREATE TABLE ipcr_function_category ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), ipcr_function_id UUID REFERENCES ipcr_function(id) ON DELETE CASCADE NOT NULL, category VARCHAR(255) NOT NULL, unit NUMERIC(4,2), immediate_supervisor_id UUID REFERENCES auth.users(id), position SMALLINT NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, UNIQUE(category, ipcr_function_id) ); -- Add index for foreign key references and position ordering CREATE INDEX idx_ipcr_function_category_function_id ON ipcr_function_category(ipcr_function_id); CREATE INDEX idx_ipcr_function_category_position ON ipcr_function_category(position, ipcr_function_id); CREATE INDEX idx_ipcr_function_category_supervisor_id ON ipcr_function_category(immediate_supervisor_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON ipcr_function_category FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241224134050_create_ipcr_sub_category_table.sql

```sql
-- Create ipcr_function_sub_category table CREATE TABLE ipcr_function_sub_category ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), ipcr_function_category_id UUID REFERENCES ipcr_function_category(id) ON DELETE CASCADE NOT NULL, sub_category VARCHAR(255) NOT NULL, position INTEGER NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Add indexes for better query performance CREATE INDEX idx_ipcr_function_sub_category_category_id ON ipcr_function_sub_category(ipcr_function_category_id); CREATE INDEX idx_ipcr_function_sub_category_position ON ipcr_function_sub_category(position, ipcr_function_category_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON ipcr_function_sub_category FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241224140105_create_ipcr_indicator_table.sql

```sql
-- Create status enum type CREATE TYPE ipcr_indicator_status AS ENUM ('draft', 'submitted', 'reviewing','revision', 'approved'); -- remove indicator date -- Create ipcr_indicator table CREATE TABLE ipcr_indicator ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), status ipcr_indicator_status DEFAULT 'draft' NOT NULL, ipcr_function_id UUID REFERENCES ipcr_function(id) ON DELETE CASCADE, ipcr_function_sub_category_id UUID REFERENCES ipcr_function_sub_category(id) ON DELETE CASCADE, ipcr_function_category_id UUID REFERENCES ipcr_function_category(id) ON DELETE CASCADE, final_output TEXT NOT NULL, success_indicator TEXT NOT NULL, actual_accomplishments TEXT, accomplishment_date DATE, op_activity_id UUID REFERENCES op_activity(id) ON DELETE SET NULL NOT NULL, quality_rating NUMERIC(3,2), efficiency_rating NUMERIC(3,2), timeliness_rating NUMERIC(3,2), average_rating NUMERIC(3,2), remarks TEXT, position SMALLINT NOT NULL, immediate_supervisor_id UUID REFERENCES auth.users(id) ON DELETE SET NULL, units NUMERIC(4,2), created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Add indexes for foreign key relationships and common query patterns CREATE INDEX idx_ipcr_indicator_function_id ON ipcr_indicator(ipcr_function_id); CREATE INDEX idx_ipcr_indicator_sub_category_id ON ipcr_indicator(ipcr_function_sub_category_id); CREATE INDEX idx_ipcr_indicator_category_id ON ipcr_indicator(ipcr_function_category_id); CREATE INDEX idx_ipcr_indicator_op_activity_id ON ipcr_indicator(op_activity_id); CREATE INDEX idx_ipcr_indicator_immediate_supervisor ON ipcr_indicator(immediate_supervisor_id); -- Add composite index for position ordering within categories CREATE INDEX idx_ipcr_indicator_position ON ipcr_indicator(position, ipcr_function_category_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON ipcr_indicator FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241224185423_view_op_activities.sql

```sql
-- Drop existing view if it exists DROP VIEW IF EXISTS operational_plan_activities; -- Create view for operational plan activities CREATE OR REPLACE VIEW operational_plan_activities AS SELECT op.id AS operational_plan_id, op.title AS operational_plan_title, op.implementing_unit, op.creator_id, op.unit_id, op.office_id, op.program_id, op.review_by, op.reviewer_position, op.approve_by, op.approver_position, h.id AS header_id, h.title AS header_title, h.position AS header_position, ap.id AS annual_plan_id, ap.description AS annual_plan_description, ap.position AS annual_plan_position, act.id AS activity_id, act.activity, act.input_type, act.performance_indicator, act.former_state, act.q1_target, act.q2_target, act.q3_target, act.q4_target, act.total, act.responsible_officer_unit, act.total_budgetary_requirements, act.position AS activity_position, act.created_at AS activity_created_at, act.updated_at AS activity_updated_at FROM operational_plan op LEFT JOIN op_header h ON op.id = h.operational_plan_id LEFT JOIN op_annual_plan ap ON h.id = ap.op_header_id LEFT JOIN op_activity act ON ap.id = act.op_annual_plan_id ORDER BY op.id, h.position, ap.position, act.position; -- Grant select permission to authenticated users GRANT SELECT ON operational_plan_activities TO authenticated;
```

# 20241226123705_create_ipcr_submit_checker.sql

```sql
-- First create the type if it doesn't exist DROP TYPE IF EXISTS validation_result CASCADE; CREATE TYPE validation_result AS ( is_valid boolean, validation_message text ); -- Create the validation function CREATE OR REPLACE FUNCTION validate_ipcr(p_ipcr_id UUID) RETURNS validation_result LANGUAGE plpgsql AS $$ DECLARE result validation_result; invalid_function RECORD; invalid_indicator RECORD; BEGIN -- Check if IPCR has at least one function IF NOT EXISTS ( SELECT 1 FROM ipcr_function WHERE ipcr_id = p_ipcr_id ) THEN result := (false, 'IPCR must have at least one function'); RETURN result; END IF; -- Check if each function has at least one indicator (from function, category or subcategory) SELECT f.id, f.title INTO invalid_function FROM ipcr_function f WHERE f.ipcr_id = p_ipcr_id AND NOT EXISTS ( -- Check direct function indicators SELECT 1 FROM ipcr_indicator i WHERE i.ipcr_function_id = f.id UNION ALL -- Check category indicators SELECT 1 FROM ipcr_function_category fc JOIN ipcr_indicator i ON i.ipcr_function_category_id = fc.id WHERE fc.ipcr_function_id = f.id UNION ALL -- Check subcategory indicators SELECT 1 FROM ipcr_function_category fc JOIN ipcr_function_sub_category fsc ON fsc.ipcr_function_category_id = fc.id JOIN ipcr_indicator i ON i.ipcr_function_sub_category_id = fsc.id WHERE fc.ipcr_function_id = f.id ) LIMIT 1; IF FOUND THEN result := (false, format('Function "%s": No indicators found at any level', invalid_function.title)); RETURN result; END IF; -- Check basic requirements for all indicators SELECT CASE WHEN i.final_output IS NULL THEN 'Missing Final Output' WHEN i.success_indicator IS NULL THEN 'Missing Success Indicator' WHEN i.op_activity_id IS NULL THEN 'Missing Operational Plan Activity' END as missing_field, COALESCE(f.title, fc.category, fsc.sub_category) as parent_name INTO invalid_indicator FROM ipcr_indicator i LEFT JOIN ipcr_function f ON f.id = i.ipcr_function_id LEFT JOIN ipcr_function_category fc ON fc.id = i.ipcr_function_category_id LEFT JOIN ipcr_function_sub_category fsc ON fsc.id = i.ipcr_function_sub_category_id WHERE (f.ipcr_id = p_ipcr_id OR EXISTS(SELECT 1 FROM ipcr_function parent_f WHERE parent_f.ipcr_id = p_ipcr_id AND fc.ipcr_function_id = parent_f.id)) AND ( i.final_output IS NULL OR i.success_indicator IS NULL OR i.op_activity_id IS NULL ) LIMIT 1; IF FOUND THEN result := (false, format('In %s: %s', invalid_indicator.parent_name, invalid_indicator.missing_field)); RETURN result; END IF; -- Special check for indicators directly under function SELECT CASE WHEN i.immediate_supervisor_id IS NULL THEN 'Missing Immediate Supervisor' WHEN i.units IS NULL THEN 'Missing Units' END as missing_field, f.title as function_title INTO invalid_indicator FROM ipcr_indicator i JOIN ipcr_function f ON f.id = i.ipcr_function_id WHERE f.ipcr_id = p_ipcr_id AND i.ipcr_function_category_id IS NULL AND i.ipcr_function_sub_category_id IS NULL AND ( i.immediate_supervisor_id IS NULL OR i.units IS NULL ) LIMIT 1; IF FOUND THEN result := (false, format('Direct indicator under function "%s": %s', invalid_indicator.function_title, invalid_indicator.missing_field)); RETURN result; END IF; -- If we get here, everything is valid result := (true, 'IPCR is complete and valid'); RETURN result; END; $$;
```

# 20241226155655_create_evidence_storage.sql

```sql
-- Create a new storage bucket for evidence files insert into storage.buckets (id, name, public) values ('indicator_evidence', 'indicator_evidence', false); -- Set up access control policies for evidence files CREATE POLICY "User can upload their own evidence files" ON storage.objects FOR INSERT WITH CHECK ( bucket_id = 'indicator_evidence' AND auth.uid()::text = (storage.foldername(name))[1] ); -- Allow anyone to read evidence files CREATE POLICY "Can read evidence files" ON storage.objects FOR SELECT TO public USING (bucket_id = 'indicator_evidence'); -- Allow anyone to update their own evidence files CREATE POLICY "User can update their own evidence files" ON storage.objects FOR UPDATE USING ( bucket_id = 'indicator_evidence' AND auth.uid()::text = (storage.foldername(name))[1] );
```

# 20241226155730_create_evidence_table.sql

```sql
-- Create evidence table CREATE TABLE ipcr_indicator_evidence ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), ipcr_indicator_id UUID REFERENCES ipcr_indicator(id) ON DELETE CASCADE NOT NULL, file_path TEXT NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Create index for better query performance CREATE INDEX idx_ipcr_indicator_evidence_indicator_id ON ipcr_indicator_evidence(ipcr_indicator_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON ipcr_indicator_evidence FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241229162216_create_accomplishment_report_table.sql

```sql
-- Create status enum type if it doesn't exist -- CREATE TYPE accomplishment_status AS ENUM ('draft', 'submitted', 'reviewing', 'revision', 'approved'); -- Create accomplishment_report table CREATE TABLE accomplishment_report ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), title VARCHAR(255) NOT NULL, implementing_unit TEXT NOT NULL, -- status accomplishment_status DEFAULT 'draft' NOT NULL, -- IDs and references owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL, unit_id INTEGER REFERENCES unit(id) ON DELETE CASCADE, office_id INTEGER REFERENCES office(id) ON DELETE CASCADE, program_id INTEGER REFERENCES program(id) ON DELETE CASCADE, -- Review/approval information review_by VARCHAR(255) NOT NULL, reviewer_position VARCHAR(255) NOT NULL, approve_by VARCHAR(255) NOT NULL, approver_position VARCHAR(255) NOT NULL, -- Timestamps created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Create indexes for foreign keys and common query patterns CREATE INDEX idx_accomplishment_report_owner ON accomplishment_report(owner_id); CREATE INDEX idx_accomplishment_report_unit ON accomplishment_report(unit_id); CREATE INDEX idx_accomplishment_report_office ON accomplishment_report(office_id); CREATE INDEX idx_accomplishment_report_program ON accomplishment_report(program_id); -- CREATE INDEX idx_accomplishment_report_status ON accomplishment_report(status); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON accomplishment_report FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241229170523_create_accomplishment_header.sql

```sql
-- Create accomplishment_header table CREATE TABLE accomplishment_header ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), accomplishment_report_id UUID REFERENCES accomplishment_report(id) ON DELETE CASCADE NOT NULL, position INTEGER NOT NULL, title TEXT NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Add indexes for better query performance CREATE INDEX idx_accomplishment_header_report_id ON accomplishment_header(accomplishment_report_id); CREATE INDEX idx_accomplishment_header_position ON accomplishment_header(position, accomplishment_report_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON accomplishment_header FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241229171016_create_accomplishment_annual_plan.sql

```sql
-- Create accomplishment_annual_plan table CREATE TABLE accomplishment_annual_plan ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), accomplishment_header_id UUID REFERENCES accomplishment_header(id) ON DELETE CASCADE NOT NULL, description TEXT NOT NULL, position INTEGER NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Add indexes for better query performance CREATE INDEX idx_accomplishment_annual_plan_header_id ON accomplishment_annual_plan(accomplishment_header_id); CREATE INDEX idx_accomplishment_annual_plan_position ON accomplishment_annual_plan(position, accomplishment_header_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON accomplishment_annual_plan FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20250110172658_create_accomplishment_activity.sql

```sql
-- Create input type enum CREATE TYPE input_type_accomplishment AS ENUM ('percentage', 'number', 'ratio', 'text'); -- Create accomplishment_activity table CREATE TABLE accomplishment_activity ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), accomplishment_annual_plan_id UUID REFERENCES accomplishment_annual_plan(id) ON DELETE CASCADE NOT NULL, activity TEXT NOT NULL, input_type input_type_accomplishment NOT NULL DEFAULT 'text', performance_indicator TEXT NOT NULL, annual_target TEXT NOT NULL, q1_accomplishment TEXT, q2_accomplishment TEXT, q3_accomplishment TEXT, q4_accomplishment TEXT, total TEXT, accomplishment_rate TEXT, responsible_officer_unit TEXT NOT NULL, remarks TEXT NOT NULL, position INTEGER NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Add indexes for better query performance CREATE INDEX idx_accomplishment_activity_annual_plan_id ON accomplishment_activity(accomplishment_annual_plan_id); CREATE INDEX idx_accomplishment_activity_position ON accomplishment_activity(position, accomplishment_annual_plan_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON accomplishment_activity FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20250121104852_create_view_ipcr_supervisor.sql

```sql
CREATE OR REPLACE VIEW ipcr_supervisors AS WITH combined_supervisors AS ( -- Get supervisors from categories and indicators SELECT DISTINCT f.ipcr_id, fc.immediate_supervisor_id FROM ipcr_function_category fc JOIN ipcr_function f ON f.id = fc.ipcr_function_id WHERE fc.immediate_supervisor_id IS NOT NULL UNION SELECT DISTINCT f.ipcr_id, i.immediate_supervisor_id FROM ipcr_indicator i JOIN ipcr_function f ON f.id = i.ipcr_function_id WHERE i.immediate_supervisor_id IS NOT NULL ) SELECT DISTINCT ON (cs.ipcr_id, cs.immediate_supervisor_id) cs.ipcr_id, cs.immediate_supervisor_id as id, p.first_name || ' ' || CASE WHEN p.middle_name IS NOT NULL AND p.middle_name != '' THEN p.middle_name || ' ' ELSE '' END || p.last_name as full_name, pos.name as position FROM combined_supervisors cs JOIN profiles p ON p.id = cs.immediate_supervisor_id LEFT JOIN position pos ON pos.id = p.position_id ORDER BY cs.ipcr_id, cs.immediate_supervisor_id, full_name; -- Grant necessary permissions GRANT SELECT ON ipcr_supervisors TO authenticated;
```

# 20250123092946_create_table_dpcr.sql

```sql
-- Create dpcr table CREATE TABLE dpcr ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), title VARCHAR(255) NOT NULL, review_by VARCHAR(255) NOT NULL, reviewer_position VARCHAR(255) NOT NULL, owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL, unit_id INTEGER REFERENCES unit(id) ON DELETE CASCADE, office_id INTEGER REFERENCES office(id) ON DELETE CASCADE, program_id INTEGER REFERENCES program(id) ON DELETE CASCADE, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Create indexes for foreign keys and common query patterns CREATE INDEX idx_dpcr_owner ON dpcr(owner_id); CREATE INDEX idx_dpcr_unit ON dpcr(unit_id); CREATE INDEX idx_dpcr_office ON dpcr(office_id); CREATE INDEX idx_dpcr_program ON dpcr(program_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON dpcr FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20250123093905_create_table_dpcr_assesor.sql

```sql
-- Create dpcr_assessors table CREATE TABLE dpcr_assessor ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), dpcr_id UUID REFERENCES dpcr(id) ON DELETE CASCADE NOT NULL, name VARCHAR(255) NOT NULL, position VARCHAR(255) NOT NULL, sequence INTEGER DEFAULT 0 NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Create indexes for better query performance CREATE INDEX idx_dpcr_assessor_dpcr_id ON dpcr_assessor(dpcr_id); CREATE INDEX idx_dpcr_assessor_sequence ON dpcr_assessor(sequence, dpcr_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON dpcr_assessor FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20250123094143_create_table_dpcr_function.sql

```sql
-- Create dpcr_function table CREATE TABLE dpcr_function ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), dpcr_id UUID REFERENCES dpcr(id) ON DELETE CASCADE NOT NULL, title VARCHAR(255) NOT NULL, position INTEGER NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, UNIQUE(dpcr_id, title) ); -- Create indexes for better query performance CREATE INDEX idx_dpcr_function_dpcr_id ON dpcr_function(dpcr_id); CREATE INDEX idx_dpcr_function_position ON dpcr_function(position, dpcr_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON dpcr_function FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20250123094232_create_table_dpcr_function_category.sql

```sql
-- Create dpcr_function_category table CREATE TABLE dpcr_function_category ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), dpcr_function_id UUID REFERENCES dpcr_function(id) ON DELETE CASCADE NOT NULL, category VARCHAR(255) NOT NULL, position SMALLINT NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, UNIQUE(category, dpcr_function_id) ); -- Create indexes for better query performance CREATE INDEX idx_dpcr_function_category_function_id ON dpcr_function_category(dpcr_function_id); CREATE INDEX idx_dpcr_function_category_position ON dpcr_function_category(position, dpcr_function_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON dpcr_function_category FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20250123094635_create_table_dpcr_indicator.sql

```sql
-- Create dpcr_indicator table CREATE TABLE dpcr_indicator ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), dpcr_function_id UUID REFERENCES dpcr_function(id) ON DELETE CASCADE, dpcr_function_category_id UUID REFERENCES dpcr_function_category(id) ON DELETE CASCADE, success_indicator TEXT NOT NULL, alloted_budget TEXT, division_individuals_accountable TEXT, physical_targets TEXT, actual_accomplishments TEXT, quality_rating NUMERIC(3,2), efficiency_rating NUMERIC(3,2), timeliness_rating NUMERIC(3,2), average_rating NUMERIC(3,2), remarks TEXT, position INTEGER NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Create indexes for better query performance CREATE INDEX idx_dpcr_indicator_function_id ON dpcr_indicator(dpcr_function_id); CREATE INDEX idx_dpcr_indicator_category_id ON dpcr_indicator(dpcr_function_category_id); CREATE INDEX idx_dpcr_indicator_position ON dpcr_indicator(position, dpcr_function_category_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON dpcr_indicator FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20250127132058_create_table_strategic_plan.sql

```sql
-- 20250128143622_add_years_to_strategic_plan.sql -- Create major output enum type CREATE TYPE strategic_major_output AS ENUM ( 'instruction', 'research', 'extension', 'governance_and_management' ); -- Create strategic_plan table CREATE TABLE strategic_plan ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), title VARCHAR(255) NOT NULL, major_output strategic_major_output NOT NULL, goal TEXT NOT NULL, start_year INTEGER NOT NULL CHECK (start_year >= EXTRACT(YEAR FROM NOW())), end_year INTEGER NOT NULL CHECK (end_year >= EXTRACT(YEAR FROM NOW())), owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL, unit_id INTEGER REFERENCES unit(id) ON DELETE CASCADE, office_id INTEGER REFERENCES office(id) ON DELETE CASCADE, program_id INTEGER REFERENCES program(id) ON DELETE CASCADE, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, CONSTRAINT end_year_after_start CHECK (end_year >= start_year) ); -- Create indexes for foreign keys and common query patterns CREATE INDEX idx_strategic_plan_owner ON strategic_plan(owner_id); CREATE INDEX idx_strategic_plan_unit ON strategic_plan(unit_id); CREATE INDEX idx_strategic_plan_office ON strategic_plan(office_id); CREATE INDEX idx_strategic_plan_program ON strategic_plan(program_id); CREATE INDEX idx_strategic_plan_major_output ON strategic_plan(major_output); CREATE INDEX idx_strategic_plan_years ON strategic_plan(start_year, end_year); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON strategic_plan FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20250127132919_create_table_strategic_plan_objectives.sql

```sql
-- Create strat_plan_objective table CREATE TABLE strat_plan_objective ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), strategic_plan_id UUID REFERENCES strategic_plan(id) ON DELETE CASCADE NOT NULL, objective TEXT NOT NULL, position INTEGER NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, -- Ensure objective is unique per strategic plan UNIQUE(strategic_plan_id, objective) ); -- Create indexes for better query performance CREATE INDEX idx_strat_plan_objective_strategic_plan_id ON strat_plan_objective(strategic_plan_id); CREATE INDEX idx_strat_plan_objective_position ON strat_plan_objective(position, strategic_plan_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON strat_plan_objective FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20250128122622_create_table_strategy_plan.sql

```sql
-- Create strategy_plan table CREATE TABLE strategy_plan ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), strat_plan_id UUID REFERENCES strategic_plan(id) ON DELETE CASCADE NOT NULL, description TEXT NOT NULL, position INTEGER NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, -- Ensure description is unique per strategic plan UNIQUE(strat_plan_id, description) ); -- Create indexes for better query performance CREATE INDEX idx_strategy_plan_strat_plan_id ON strategy_plan(strat_plan_id); CREATE INDEX idx_strategy_plan_position ON strategy_plan(position, strat_plan_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON strategy_plan FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20250128165836_create_table_strategy_plan_performance_indicator_table.sql

```sql
-- Create the input type enum CREATE TYPE input_type_strategic_plan AS ENUM ('percentage', 'number', 'ratio', 'text'); -- Recreate strategy_plan_performance_indicator table with new column CREATE TABLE strategy_plan_performance_indicator ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), strategy_plan_id UUID REFERENCES strategy_plan(id) ON DELETE CASCADE NOT NULL, performance_indicator TEXT NOT NULL, input_type input_type_strategic_plan NOT NULL DEFAULT 'text', base_target TEXT NOT NULL, actual_target TEXT NOT NULL, concerned_offices TEXT, remarks TEXT, position INTEGER NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Create indexes for better query performance CREATE INDEX idx_strategy_plan_performance_indicator_strategy_plan_id ON strategy_plan_performance_indicator(strategy_plan_id); CREATE INDEX idx_strategy_plan_performance_indicator_position ON strategy_plan_performance_indicator(position, strategy_plan_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON strategy_plan_performance_indicator FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20250128170002_create_table_sdg_alignment_table_view.sql

```sql
-- Create sdg_alignment table CREATE TABLE sdg_alignment ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), strat_plan_objective_id UUID REFERENCES strat_plan_objective(id) ON DELETE CASCADE NOT NULL, strat_plan_performance_indicator_id UUID REFERENCES strategy_plan_performance_indicator(id) ON DELETE CASCADE NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, -- Ensure unique combination of objective and performance indicator UNIQUE(strat_plan_objective_id, strat_plan_performance_indicator_id) ); -- Create indexes for foreign keys CREATE INDEX idx_sdg_alignment_objective_id ON sdg_alignment(strat_plan_objective_id); CREATE INDEX idx_sdg_alignment_performance_indicator_id ON sdg_alignment(strat_plan_performance_indicator_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON sdg_alignment FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at(); -- Create view for SDG alignments with related data CREATE OR REPLACE VIEW sdg_alignment_view AS SELECT sa.id as alignment_id, sa.created_at as alignment_created_at, sa.updated_at as alignment_updated_at, -- Strategic Plan data sp.id as strategic_plan_id, sp.title as strategic_plan_title, sp.major_output, sp.goal as strategic_plan_goal, -- Objective data spo.id as objective_id, spo.objective, spo.position as objective_position, -- Performance Indicator data sppi.id as performance_indicator_id, sppi.base_target, sppi.actual_target, sppi.concerned_offices, sppi.remarks as performance_indicator_remarks, sppi.position as performance_indicator_position FROM sdg_alignment sa JOIN strat_plan_objective spo ON sa.strat_plan_objective_id = spo.id JOIN strategy_plan_performance_indicator sppi ON sa.strat_plan_performance_indicator_id = sppi.id JOIN strategic_plan sp ON spo.strategic_plan_id = sp.id; -- Grant necessary permissions GRANT SELECT ON sdg_alignment_view TO authenticated;
```

# 20250128170045_create_table_strat_plan_yearly_plan.sql

```sql
-- Create strat_plan_yearly_plan table CREATE TABLE strat_plan_yearly_plan ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), strategy_plan_performance_indicator_id UUID REFERENCES strategy_plan_performance_indicator(id) ON DELETE CASCADE NOT NULL, year INTEGER NOT NULL, target TEXT NOT NULL, budget NUMERIC NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, -- Ensure unique combination of performance indicator and year UNIQUE(strategy_plan_performance_indicator_id, year) ); -- Create index for foreign key CREATE INDEX idx_strat_plan_yearly_plan_performance_indicator_id ON strat_plan_yearly_plan(strategy_plan_performance_indicator_id); -- Create index for year queries CREATE INDEX idx_strat_plan_yearly_plan_year ON strat_plan_yearly_plan(year); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON strat_plan_yearly_plan FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20250131164632_create_table_opcr.sql

```sql
-- Create opcr table CREATE TABLE opcr ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), title VARCHAR(255) NOT NULL, review_by VARCHAR(255) NOT NULL, reviewer_position VARCHAR(255) NOT NULL, administrative_officer VARCHAR(255) NOT NULL, planning_officer VARCHAR(255) NOT NULL, human_resource VARCHAR(255) NOT NULL, owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL, unit_id INTEGER REFERENCES unit(id) ON DELETE CASCADE, office_id INTEGER REFERENCES office(id) ON DELETE CASCADE, program_id INTEGER REFERENCES program(id) ON DELETE CASCADE, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Create indexes for foreign keys and common query patterns CREATE INDEX idx_opcr_owner ON opcr(owner_id); CREATE INDEX idx_opcr_unit ON opcr(unit_id); CREATE INDEX idx_opcr_office ON opcr(office_id); CREATE INDEX idx_opcr_program ON opcr(program_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON opcr FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20250131164807_create_table_opcr_function.sql

```sql
-- Create opcr_function table CREATE TABLE opcr_function ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), opcr_id UUID REFERENCES opcr(id) ON DELETE CASCADE NOT NULL, title VARCHAR(255) NOT NULL, position INTEGER NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, UNIQUE(opcr_id, title) ); -- Create indexes for better query performance CREATE INDEX idx_opcr_function_opcr_id ON opcr_function(opcr_id); CREATE INDEX idx_opcr_function_position ON opcr_function(position, opcr_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON opcr_function FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20250131164956_create_table_opcr_function_category.sql

```sql
-- Create opcr_function_category table CREATE TABLE opcr_function_category ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), opcr_function_id UUID REFERENCES opcr_function(id) ON DELETE CASCADE NOT NULL, category VARCHAR(255) NOT NULL, position SMALLINT NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, UNIQUE(category, opcr_function_id) ); -- Create indexes for better query performance CREATE INDEX idx_opcr_function_category_function_id ON opcr_function_category(opcr_function_id); CREATE INDEX idx_opcr_function_category_position ON opcr_function_category(position, opcr_function_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON opcr_function_category FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20250131165054_create_table_opcr_function_indicator.sql

```sql
-- Create opcr_indicator table -- Create opcr_indicator table CREATE TABLE opcr_indicator ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), opcr_function_id UUID REFERENCES opcr_function(id) ON DELETE CASCADE, opcr_function_category_id UUID REFERENCES opcr_function_category(id) ON DELETE CASCADE, success_indicator TEXT NOT NULL, alloted_budget TEXT, division_individuals_accountable TEXT, actual_accomplishments TEXT, quality_rating NUMERIC(3,2), efficiency_rating NUMERIC(3,2), timeliness_rating NUMERIC(3,2), average_rating NUMERIC(3,2), remarks TEXT, position INTEGER NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Create indexes for better query performance CREATE INDEX idx_opcr_indicator_function_id ON opcr_indicator(opcr_function_id); CREATE INDEX idx_opcr_indicator_category_id ON opcr_indicator(opcr_function_category_id); CREATE INDEX idx_opcr_indicator_position ON opcr_indicator(position, opcr_function_category_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON opcr_indicator FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20250203065721_create_function_get_ipcr_id_from_indicator.sql

```sql
CREATE OR REPLACE FUNCTION get_ipcr_id_from_indicator(p_indicator_id UUID) RETURNS UUID LANGUAGE plpgsql AS $$ DECLARE v_ipcr_id UUID; BEGIN -- Try to get IPCR ID through function SELECT f.ipcr_id INTO v_ipcr_id FROM ipcr_indicator i JOIN ipcr_function f ON i.ipcr_function_id = f.id WHERE i.id = p_indicator_id; -- If not found, try through category IF v_ipcr_id IS NULL THEN SELECT f.ipcr_id INTO v_ipcr_id FROM ipcr_indicator i JOIN ipcr_function_category fc ON i.ipcr_function_category_id = fc.id JOIN ipcr_function f ON fc.ipcr_function_id = f.id WHERE i.id = p_indicator_id; END IF; -- If still not found, try through sub-category IF v_ipcr_id IS NULL THEN SELECT f.ipcr_id INTO v_ipcr_id FROM ipcr_indicator i JOIN ipcr_function_sub_category fsc ON i.ipcr_function_sub_category_id = fsc.id JOIN ipcr_function_category fc ON fsc.ipcr_function_category_id = fc.id JOIN ipcr_function f ON fc.ipcr_function_id = f.id WHERE i.id = p_indicator_id; END IF; RETURN v_ipcr_id; END; $$;
```

# 20250203125746_create_table_blockchain_data.sql

```sql
-- Create blockchain_data table CREATE TABLE blockchain_data ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), file_cid TEXT NOT NULL, action TEXT NOT NULL DEFAULT 'backup', file_name TEXT NOT NULL, type TEXT NOT NULL DEFAULT 'data/evidence', blockchain_hash TEXT NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Create indexes for better query performance CREATE INDEX idx_blockchain_data_file_cid ON blockchain_data(file_cid); CREATE INDEX idx_blockchain_data_file_name ON blockchain_data(file_name); CREATE INDEX idx_blockchain_data_type ON blockchain_data(type); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON blockchain_data FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at(); -- Enable Row Level Security ALTER TABLE blockchain_data ENABLE ROW LEVEL SECURITY; -- Create policies for authenticated users CREATE POLICY "Enable read access for all authenticated users" ON blockchain_data FOR SELECT TO authenticated USING (true); CREATE POLICY "Enable insert for authenticated users" ON blockchain_data FOR INSERT TO authenticated WITH CHECK (true);
```

# 20250203162152_ipcr_view.sql

```sql
CREATE OR REPLACE VIEW ipcr_backup_view AS SELECT -- IPCR Basic Details i.id as ipcr_id, i.title as ipcr_title, i.status as ipcr_status, i.head_of_operating_unit, i.program_chair, i.dean, -- Owner Profile Details p.id as owner_id, p.employee_id as owner_employee_id, p.first_name as owner_first_name, p.middle_name as owner_middle_name, p.last_name as owner_last_name, p.email as owner_email, -- Owner Position Details pos.name as owner_position_name, now_type.type as owner_nature_of_work, emp_status.type as owner_employee_status, -- Owner Unit Details owner_unit.id as owner_unit_id, owner_unit.code as owner_unit_code, owner_unit.name as owner_unit_name, -- Owner Office Details owner_office.id as owner_office_id, owner_office.code as owner_office_code, owner_office.name as owner_office_name, -- Owner Program Details owner_program.id as owner_program_id, owner_program.name as owner_program_name, -- IPCR Organization Details ipcr_unit.id as ipcr_unit_id, ipcr_unit.code as ipcr_unit_code, ipcr_unit.name as ipcr_unit_name, ipcr_office.id as ipcr_office_id, ipcr_office.code as ipcr_office_code, ipcr_office.name as ipcr_office_name, ipcr_program.id as ipcr_program_id, ipcr_program.name as ipcr_program_name, -- Function Details f.id as function_id, f.title as function_title, f.percentage as function_percentage, f.position as function_position, -- Category Details fc.id as category_id, fc.category, fc.unit as category_unit, fc.position as category_position, -- Category Supervisor Details cat_sup_profile.employee_id as category_supervisor_employee_id, cat_sup_profile.first_name as category_supervisor_first_name, cat_sup_profile.middle_name as category_supervisor_middle_name, cat_sup_profile.last_name as category_supervisor_last_name, cat_sup_pos.name as category_supervisor_position, -- Sub Category Details fsc.id as subcategory_id, fsc.sub_category, fsc.position as subcategory_position, -- Indicator Details ind.id as indicator_id, ind.final_output, ind.success_indicator, ind.actual_accomplishments, ind.accomplishment_date, ind.quality_rating, ind.efficiency_rating, ind.timeliness_rating, ind.average_rating, ind.remarks, ind.units as indicator_units, ind.position as indicator_position, -- Indicator Supervisor Details ind_sup_profile.employee_id as indicator_supervisor_employee_id, ind_sup_profile.first_name as indicator_supervisor_first_name, ind_sup_profile.middle_name as indicator_supervisor_middle_name, ind_sup_profile.last_name as indicator_supervisor_last_name, ind_sup_pos.name as indicator_supervisor_position, -- Operational Plan Activity Details op_act.activity as op_activity, op_act.performance_indicator as op_performance_indicator, op_act.responsible_officer_unit as op_responsible_officer_unit, -- Evidence Details ( SELECT json_agg ( json_build_object ( 'id', e.id, 'file_path', e.file_path, 'created_at', e.created_at ) ) FROM ipcr_indicator_evidence e WHERE e.ipcr_indicator_id = ind.id ) as evidence_files, -- Timestamps i.created_at, i.updated_at FROM ipcr i -- Owner joins LEFT JOIN profiles p ON i.owner_id = p.id LEFT JOIN position pos ON p.position_id = pos.id LEFT JOIN nature_of_work now_type ON p.nature_of_work_id = now_type.id LEFT JOIN employee_status emp_status ON p.employee_status_id = emp_status.id LEFT JOIN unit owner_unit ON p.unit_id = owner_unit.id LEFT JOIN office owner_office ON p.office_id = owner_office.id LEFT JOIN program owner_program ON p.program_id = owner_program.id -- IPCR Organization joins LEFT JOIN unit ipcr_unit ON i.unit_id = ipcr_unit.id LEFT JOIN office ipcr_office ON i.office_id = ipcr_office.id LEFT JOIN program ipcr_program ON i.program_id = ipcr_program.id -- IPCR hierarchy joins LEFT JOIN ipcr_function f ON i.id = f.ipcr_id LEFT JOIN ipcr_function_category fc ON f.id = fc.ipcr_function_id LEFT JOIN ipcr_function_sub_category fsc ON fc.id = fsc.ipcr_function_category_id -- Category supervisor joins LEFT JOIN profiles cat_sup_profile ON fc.immediate_supervisor_id = cat_sup_profile.id LEFT JOIN position cat_sup_pos ON cat_sup_profile.position_id = cat_sup_pos.id -- Indicator joins and its supervisor LEFT JOIN ipcr_indicator ind ON ( ind.ipcr_function_id = f.id OR ind.ipcr_function_category_id = fc.id OR ind.ipcr_function_sub_category_id = fsc.id ) LEFT JOIN profiles ind_sup_profile ON ind.immediate_supervisor_id = ind_sup_profile.id LEFT JOIN position ind_sup_pos ON ind_sup_profile.position_id = ind_sup_pos.id -- Operational plan activity join LEFT JOIN op_activity op_act ON ind.op_activity_id = op_act.id; -- Grant SELECT permission to authenticated users GRANT SELECT ON ipcr_backup_view TO authenticated;
```

# 20250204155815_create_opeartional_backup_view.sql

```sql
-- Create a comprehensive view for operational plans and their activities CREATE OR REPLACE VIEW operational_backup_view AS SELECT -- Operational Plan details op.id as operational_plan_id, op.title as operational_plan_title, op.implementing_unit, op.review_by, op.reviewer_position, op.approve_by, op.approver_position, -- Creator Profile details p.id as creator_id, p.employee_id as creator_employee_id, p.first_name as creator_first_name, p.middle_name as creator_middle_name, p.last_name as creator_last_name, p.email as creator_email, -- Creator's Position details pos.name as creator_position_name, now_type.type as creator_nature_of_work, emp_status.type as creator_employee_status, -- Creator's Unit details creator_unit.code as creator_unit_code, creator_unit.name as creator_unit_name, -- Creator's Office details creator_office.code as creator_office_code, creator_office.name as creator_office_name, -- Creator's Program details creator_program.name as creator_program_name, -- Operational Plan Unit details op_unit.code as op_unit_code, op_unit.name as op_unit_name, -- Operational Plan Office details op_office.code as op_office_code, op_office.name as op_office_name, -- Operational Plan Program details op_program.name as op_program_name, -- Header details h.id as header_id, h.title as header_title, h.position as header_position, -- Annual Plan details ap.id as annual_plan_id, ap.description as annual_plan_description, ap.position as annual_plan_position, -- Activity details act.id as activity_id, act.activity, act.input_type, act.performance_indicator, act.former_state, act.q1_target, act.q2_target, act.q3_target, act.q4_target, act.total, act.responsible_officer_unit, act.total_budgetary_requirements, act.position as activity_position, -- Timestamps op.created_at, op.updated_at FROM operational_plan op -- Creator joins LEFT JOIN profiles p ON op.creator_id = p.id LEFT JOIN position pos ON p.position_id = pos.id LEFT JOIN nature_of_work now_type ON p.nature_of_work_id = now_type.id LEFT JOIN employee_status emp_status ON p.employee_status_id = emp_status.id LEFT JOIN unit creator_unit ON p.unit_id = creator_unit.id LEFT JOIN office creator_office ON p.office_id = creator_office.id LEFT JOIN program creator_program ON p.program_id = creator_program.id -- Operational Plan entity joins LEFT JOIN unit op_unit ON op.unit_id = op_unit.id LEFT JOIN office op_office ON op.office_id = op_office.id LEFT JOIN program op_program ON op.program_id = op_program.id -- Operational Plan hierarchy joins LEFT JOIN op_header h ON op.id = h.operational_plan_id LEFT JOIN op_annual_plan ap ON h.id = ap.op_header_id LEFT JOIN op_activity act ON ap.id = act.op_annual_plan_id; -- Grant SELECT permission to authenticated users GRANT SELECT ON operational_backup_view TO authenticated;
```

# 20250204160342_create_dpcr_backup_view.sql

```sql
CREATE OR REPLACE VIEW dpcr_backup_view AS WITH grouped_assessors AS ( SELECT dpcr_id, json_agg ( json_build_object ( 'id', id, 'name', name, 'position', position, 'sequence', sequence ) ORDER BY sequence ) as assessors FROM dpcr_assessor GROUP BY dpcr_id ) SELECT -- DPCR Basic Details d.id as dpcr_id, d.title as dpcr_title, d.review_by, d.reviewer_position, -- Owner Profile Details p.id as owner_id, p.employee_id as owner_employee_id, p.first_name as owner_first_name, p.middle_name as owner_middle_name, p.last_name as owner_last_name, p.email as owner_email, -- Owner Position Details pos.name as owner_position_name, now_type.type as owner_nature_of_work, emp_status.type as owner_employee_status, -- Owner Unit Details owner_unit.id as owner_unit_id, owner_unit.code as owner_unit_code, owner_unit.name as owner_unit_name, -- Owner Office Details owner_office.id as owner_office_id, owner_office.code as owner_office_code, owner_office.name as owner_office_name, -- Owner Program Details owner_program.id as owner_program_id, owner_program.name as owner_program_name, -- DPCR Organization Details dpcr_unit.id as dpcr_unit_id, dpcr_unit.code as dpcr_unit_code, dpcr_unit.name as dpcr_unit_name, dpcr_office.id as dpcr_office_id, dpcr_office.code as dpcr_office_code, dpcr_office.name as dpcr_office_name, dpcr_program.id as dpcr_program_id, dpcr_program.name as dpcr_program_name, -- Assessor Details as JSON array ga.assessors, -- Function Details f.id as function_id, f.title as function_title, f.position as function_position, -- Category Details fc.id as category_id, fc.category, fc.position as category_position, -- Indicator Details ind.id as indicator_id, ind.success_indicator, ind.alloted_budget, ind.division_individuals_accountable, ind.physical_targets, ind.actual_accomplishments, ind.quality_rating, ind.efficiency_rating, ind.timeliness_rating, ind.average_rating, ind.remarks, ind.position as indicator_position, -- Timestamps d.created_at, d.updated_at FROM dpcr d -- Owner joins LEFT JOIN profiles p ON d.owner_id = p.id LEFT JOIN position pos ON p.position_id = pos.id LEFT JOIN nature_of_work now_type ON p.nature_of_work_id = now_type.id LEFT JOIN employee_status emp_status ON p.employee_status_id = emp_status.id LEFT JOIN unit owner_unit ON p.unit_id = owner_unit.id LEFT JOIN office owner_office ON p.office_id = owner_office.id LEFT JOIN program owner_program ON p.program_id = owner_program.id -- DPCR Organization joins LEFT JOIN unit dpcr_unit ON d.unit_id = dpcr_unit.id LEFT JOIN office dpcr_office ON d.office_id = dpcr_office.id LEFT JOIN program dpcr_program ON d.program_id = dpcr_program.id -- Assessors join LEFT JOIN grouped_assessors ga ON d.id = ga.dpcr_id -- DPCR hierarchy joins LEFT JOIN dpcr_function f ON d.id = f.dpcr_id LEFT JOIN dpcr_function_category fc ON f.id = fc.dpcr_function_id LEFT JOIN dpcr_indicator ind ON ( ind.dpcr_function_id = f.id OR ind.dpcr_function_category_id = fc.id ); -- Grant SELECT permission to authenticated users GRANT SELECT ON dpcr_backup_view TO authenticated;
```

# 20250204160856_create_opcr_backup_view.sql

```sql
CREATE OR REPLACE VIEW opcr_backup_view AS SELECT -- OPCR Basic Details o.id as opcr_id, o.title as opcr_title, o.review_by, o.reviewer_position, o.administrative_officer, o.planning_officer, o.human_resource, -- Owner Profile Details p.id as owner_id, p.employee_id as owner_employee_id, p.first_name as owner_first_name, p.middle_name as owner_middle_name, p.last_name as owner_last_name, p.email as owner_email, -- Owner Position Details pos.name as owner_position_name, now_type.type as owner_nature_of_work, emp_status.type as owner_employee_status, -- Owner Unit Details owner_unit.id as owner_unit_id, owner_unit.code as owner_unit_code, owner_unit.name as owner_unit_name, -- Owner Office Details owner_office.id as owner_office_id, owner_office.code as owner_office_code, owner_office.name as owner_office_name, -- Owner Program Details owner_program.id as owner_program_id, owner_program.name as owner_program_name, -- OPCR Organization Details opcr_unit.id as opcr_unit_id, opcr_unit.code as opcr_unit_code, opcr_unit.name as opcr_unit_name, opcr_office.id as opcr_office_id, opcr_office.code as opcr_office_code, opcr_office.name as opcr_office_name, opcr_program.id as opcr_program_id, opcr_program.name as opcr_program_name, -- Function Details f.id as function_id, f.title as function_title, f.position as function_position, -- Category Details fc.id as category_id, fc.category, fc.position as category_position, -- Indicator Details ind.id as indicator_id, ind.success_indicator, ind.alloted_budget, ind.division_individuals_accountable, ind.actual_accomplishments, ind.quality_rating, ind.efficiency_rating, ind.timeliness_rating, ind.average_rating, ind.remarks, ind.position as indicator_position, -- Strategic Plan Alignment Details sp.id as strategic_plan_id, sp.title as strategic_plan_title, sp.major_output as strategic_plan_major_output, sp.goal as strategic_plan_goal, sp.start_year as strategic_plan_start_year, sp.end_year as strategic_plan_end_year, -- Timestamps o.created_at, o.updated_at FROM opcr o -- Owner joins LEFT JOIN profiles p ON o.owner_id = p.id LEFT JOIN position pos ON p.position_id = pos.id LEFT JOIN nature_of_work now_type ON p.nature_of_work_id = now_type.id LEFT JOIN employee_status emp_status ON p.employee_status_id = emp_status.id LEFT JOIN unit owner_unit ON p.unit_id = owner_unit.id LEFT JOIN office owner_office ON p.office_id = owner_office.id LEFT JOIN program owner_program ON p.program_id = owner_program.id -- OPCR Organization joins LEFT JOIN unit opcr_unit ON o.unit_id = opcr_unit.id LEFT JOIN office opcr_office ON o.office_id = opcr_office.id LEFT JOIN program opcr_program ON o.program_id = opcr_program.id -- OPCR hierarchy joins LEFT JOIN opcr_function f ON o.id = f.opcr_id LEFT JOIN opcr_function_category fc ON f.id = fc.opcr_function_id LEFT JOIN opcr_indicator ind ON ( ind.opcr_function_id = f.id OR ind.opcr_function_category_id = fc.id ) -- Strategic Plan join (assuming there might be a relation to strategic plan in the future) LEFT JOIN strategic_plan sp ON ( (o.unit_id = sp.unit_id) AND ( o.office_id IS NULL OR o.office_id = sp.office_id ) AND ( o.program_id IS NULL OR o.program_id = sp.program_id ) AND ( EXTRACT( YEAR FROM o.created_at ) BETWEEN sp.start_year AND sp.end_year ) ); -- Grant SELECT permission to authenticated users GRANT SELECT ON opcr_backup_view TO authenticated;
```

# 20250204160955_create_stategic_plan_backup_view.sql

```sql
CREATE OR REPLACE VIEW strategic_plan_backup_view AS SELECT -- Strategic Plan Basic Details sp.id as strategic_plan_id, sp.title as strategic_plan_title, sp.major_output, sp.goal, sp.start_year, sp.end_year, -- Owner Profile Details p.id as owner_id, p.employee_id as owner_employee_id, p.first_name as owner_first_name, p.middle_name as owner_middle_name, p.last_name as owner_last_name, p.email as owner_email, -- Owner Position Details pos.name as owner_position_name, now_type.type as owner_nature_of_work, emp_status.type as owner_employee_status, -- Owner Unit Details owner_unit.id as owner_unit_id, owner_unit.code as owner_unit_code, owner_unit.name as owner_unit_name, -- Owner Office Details owner_office.id as owner_office_id, owner_office.code as owner_office_code, owner_office.name as owner_office_name, -- Owner Program Details owner_program.id as owner_program_id, owner_program.name as owner_program_name, -- Strategic Plan Organization Details sp_unit.id as sp_unit_id, sp_unit.code as sp_unit_code, sp_unit.name as sp_unit_name, sp_office.id as sp_office_id, sp_office.code as sp_office_code, sp_office.name as sp_office_name, sp_program.id as sp_program_id, sp_program.name as sp_program_name, -- Objective Details obj.id as objective_id, obj.objective, obj.position as objective_position, -- Strategy Details strat.id as strategy_id, strat.description as strategy_description, strat.position as strategy_position, -- Performance Indicator Details pi.id as performance_indicator_id, pi.performance_indicator, pi.input_type, pi.base_target, pi.actual_target, pi.concerned_offices, pi.remarks as pi_remarks, pi.position as pi_position, -- Yearly Plan Details ( SELECT json_agg ( json_build_object ( 'id', yp.id, 'year', yp.year, 'target', yp.target, 'budget', yp.budget ) ORDER BY yp.year ) FROM strat_plan_yearly_plan yp WHERE yp.strategy_plan_performance_indicator_id = pi.id ) as yearly_plans, -- SDG Alignment Details ( SELECT json_agg ( json_build_object ( 'alignment_id', sa.id, 'objective_id', sa.strat_plan_objective_id, 'performance_indicator_id', sa.strat_plan_performance_indicator_id ) ) FROM sdg_alignment sa WHERE sa.strat_plan_objective_id = obj.id ) as sdg_alignments, -- Related OPCR Details (if any) ( SELECT json_agg ( json_build_object ( 'opcr_id', o.id, 'title', o.title, 'review_by', o.review_by, 'reviewer_position', o.reviewer_position ) ) FROM opcr o WHERE o.unit_id = sp.unit_id AND ( o.office_id IS NULL OR o.office_id = sp.office_id ) AND ( o.program_id IS NULL OR o.program_id = sp.program_id ) AND ( EXTRACT( YEAR FROM o.created_at ) BETWEEN sp.start_year AND sp.end_year ) ) as related_opcrs, -- Timestamps sp.created_at, sp.updated_at FROM strategic_plan sp -- Owner joins LEFT JOIN profiles p ON sp.owner_id = p.id LEFT JOIN position pos ON p.position_id = pos.id LEFT JOIN nature_of_work now_type ON p.nature_of_work_id = now_type.id LEFT JOIN employee_status emp_status ON p.employee_status_id = emp_status.id LEFT JOIN unit owner_unit ON p.unit_id = owner_unit.id LEFT JOIN office owner_office ON p.office_id = owner_office.id LEFT JOIN program owner_program ON p.program_id = owner_program.id -- Strategic Plan Organization joins LEFT JOIN unit sp_unit ON sp.unit_id = sp_unit.id LEFT JOIN office sp_office ON sp.office_id = sp_office.id LEFT JOIN program sp_program ON sp.program_id = sp_program.id -- Strategic Plan hierarchy joins LEFT JOIN strat_plan_objective obj ON sp.id = obj.strategic_plan_id LEFT JOIN strategy_plan strat ON sp.id = strat.strat_plan_id LEFT JOIN strategy_plan_performance_indicator pi ON strat.id = pi.strategy_plan_id; -- Grant SELECT permission to authenticated users GRANT SELECT ON strategic_plan_backup_view TO authenticated;
```

# 20250204161122_create_accomplishment_report_backup_view.sql

```sql
CREATE OR REPLACE VIEW accomplishment_report_backup_view AS SELECT -- Accomplishment Report Basic Details ar.id as accomplishment_report_id, ar.title as accomplishment_report_title, ar.implementing_unit, -- ar.status as accomplishment_status, ar.review_by, ar.reviewer_position, ar.approve_by, ar.approver_position, -- Owner Profile Details p.id as owner_id, p.employee_id as owner_employee_id, p.first_name as owner_first_name, p.middle_name as owner_middle_name, p.last_name as owner_last_name, p.email as owner_email, -- Owner Position Details pos.name as owner_position_name, now_type.type as owner_nature_of_work, emp_status.type as owner_employee_status, -- Owner Unit Details owner_unit.id as owner_unit_id, owner_unit.code as owner_unit_code, owner_unit.name as owner_unit_name, -- Owner Office Details owner_office.id as owner_office_id, owner_office.code as owner_office_code, owner_office.name as owner_office_name, -- Owner Program Details owner_program.id as owner_program_id, owner_program.name as owner_program_name, -- Accomplishment Report Organization Details ar_unit.id as ar_unit_id, ar_unit.code as ar_unit_code, ar_unit.name as ar_unit_name, ar_office.id as ar_office_id, ar_office.code as ar_office_code, ar_office.name as ar_office_name, ar_program.id as ar_program_id, ar_program.name as ar_program_name, -- Header Details h.id as header_id, h.title as header_title, h.position as header_position, -- Annual Plan Details ap.id as annual_plan_id, ap.description as annual_plan_description, ap.position as annual_plan_position, -- Activity Details act.id as activity_id, act.activity, act.input_type, act.performance_indicator, act.annual_target, act.q1_accomplishment, act.q2_accomplishment, act.q3_accomplishment, act.q4_accomplishment, act.total, act.accomplishment_rate, act.responsible_officer_unit, act.remarks as activity_remarks, act.position as activity_position, -- IPCR Indicators Related to Activities ( SELECT json_agg ( json_build_object ( 'indicator_id', i.id, 'final_output', i.final_output, 'success_indicator', i.success_indicator, 'actual_accomplishments', i.actual_accomplishments, 'average_rating', i.average_rating, 'ipcr_id', get_ipcr_id_from_indicator (i.id) ) ) FROM ipcr_indicator i WHERE i.actual_accomplishments IS NOT NULL AND EXISTS ( -- Check if accomplishment is within the same organizational unit/scope SELECT 1 FROM ipcr ipcr_parent WHERE get_ipcr_id_from_indicator (i.id) = ipcr_parent.id AND ( (ar.unit_id = ipcr_parent.unit_id) AND ( ar.office_id IS NULL OR ar.office_id = ipcr_parent.office_id ) AND ( ar.program_id IS NULL OR ar.program_id = ipcr_parent.program_id ) ) ) ) as related_ipcr_indicators, -- Timestamps ar.created_at, ar.updated_at FROM accomplishment_report ar -- Owner joins LEFT JOIN profiles p ON ar.owner_id = p.id LEFT JOIN position pos ON p.position_id = pos.id LEFT JOIN nature_of_work now_type ON p.nature_of_work_id = now_type.id LEFT JOIN employee_status emp_status ON p.employee_status_id = emp_status.id LEFT JOIN unit owner_unit ON p.unit_id = owner_unit.id LEFT JOIN office owner_office ON p.office_id = owner_office.id LEFT JOIN program owner_program ON p.program_id = owner_program.id -- Accomplishment Report Organization joins LEFT JOIN unit ar_unit ON ar.unit_id = ar_unit.id LEFT JOIN office ar_office ON ar.office_id = ar_office.id LEFT JOIN program ar_program ON ar.program_id = ar_program.id -- Accomplishment Report hierarchy joins LEFT JOIN accomplishment_header h ON ar.id = h.accomplishment_report_id LEFT JOIN accomplishment_annual_plan ap ON h.id = ap.accomplishment_header_id LEFT JOIN accomplishment_activity act ON ap.id = act.accomplishment_annual_plan_id; -- Grant SELECT permission to authenticated users GRANT SELECT ON accomplishment_report_backup_view TO authenticated;
```

# 20250213164618_create_strategic_plan_permissions.sql

```sql
INSERT INTO permissions (name, description) VALUES ( 'create_strategic_plan', 'Permission to create strategic plans' ), ( 'view_strategic_plan', 'Permission to view strategic plans' ), ( 'update_strategic_plan', 'Permission to update strategic plans' ), ( 'delete_strategic_plan', 'Permission to delete strategic plans' );
```

