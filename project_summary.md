# 20241116152556_create_table_unit.sql

```sql
-- Create the function for updating timestamps CREATE OR REPLACE FUNCTION fn_set_updated_at() RETURNS TRIGGER AS $$ BEGIN NEW.updated_at = TIMEZONE('utc'::text, NOW()); RETURN NEW; END; $$ LANGUAGE plpgsql; -- Create the unit table CREATE TABLE unit ( id INTEGER GENERATED BY DEFAULT AS IDENTITY NOT NULL PRIMARY KEY, code VARCHAR(50) NOT NULL UNIQUE, name TEXT NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Create index on commonly searched columns CREATE INDEX idx_unit_code ON unit(code); -- Add updated_at trigger CREATE TRIGGER set_updated_at BEFORE UPDATE ON unit FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241116153626_create_table_nature_of_work.sql

```sql
-- create table CREATE TABLE nature_of_work ( id INTEGER GENERATED BY DEFAULT AS IDENTITY NOT NULL PRIMARY KEY, type VARCHAR(100) NOT NULL UNIQUE, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Add updated_at trigger CREATE TRIGGER set_updated_at BEFORE UPDATE ON nature_of_work FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241116155829_create_table_office.sql

```sql
CREATE TABLE office ( id INTEGER GENERATED BY DEFAULT AS IDENTITY NOT NULL PRIMARY KEY, unit_id INTEGER NOT NULL REFERENCES unit(id), code VARCHAR(50) NOT NULL UNIQUE, name VARCHAR(200) NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Create index for foreign key CREATE INDEX idx_office_unit_id ON office(unit_id); -- Add updated_at trigger CREATE TRIGGER set_updated_at BEFORE UPDATE ON office FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241116160732_create_table_program.sql

```sql
CREATE TABLE program ( id INTEGER GENERATED BY DEFAULT AS IDENTITY NOT NULL PRIMARY KEY, unit_id INTEGER NOT NULL REFERENCES unit(id), office_id INTEGER NOT NULL REFERENCES office(id), name TEXT NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Create indexes for foreign keys CREATE INDEX idx_program_unit_id ON program(unit_id); CREATE INDEX idx_program_office_id ON program(office_id); -- Add updated_at trigger CREATE TRIGGER set_updated_at BEFORE UPDATE ON program FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241116161506_create_table_position.sql

```sql
CREATE TABLE position ( id INTEGER GENERATED BY DEFAULT AS IDENTITY NOT NULL PRIMARY KEY, nature_of_work_id INTEGER NOT NULL REFERENCES nature_of_work(id), name VARCHAR(100) NOT NULL UNIQUE, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Create index for foreign key CREATE INDEX idx_position_nature_of_work_id ON position(nature_of_work_id); -- Add updated_at trigger CREATE TRIGGER set_updated_at BEFORE UPDATE ON position FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241116161733_create_table_employee_status.sql

```sql
-- create table CREATE TABLE employee_status ( id INTEGER GENERATED BY DEFAULT AS IDENTITY NOT NULL PRIMARY KEY, type VARCHAR(100) NOT NULL UNIQUE, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Add updated_at trigger CREATE TRIGGER set_updated_at BEFORE UPDATE ON employee_status FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241116162523_create_table_profile.sql

```sql
-- Create a table for public profiles create table profiles ( id uuid references auth.users on delete cascade not null primary key, updated_at timestamp with time zone default timezone('utc'::text, now()), employee_id varchar(50) unique, email varchar(255) unique, first_name text, middle_name text, last_name text, avatar_url text, unit_id integer references unit(id), nature_of_work_id integer references nature_of_work(id), office_id integer references office(id), program_id integer references program(id), position_id integer references position(id), employee_status_id integer references employee_status(id), created_at timestamp with time zone default timezone('utc'::text, now()) ); -- Set up Row Level Security (RLS) alter table profiles enable row level security; create policy "Public profiles are viewable by everyone." on profiles for select using (true); create policy "Users can insert their own profile." on profiles for insert with check ((select auth.uid()) = id); create policy "Users can update own profile." on profiles for update using ((select auth.uid()) = id); -- Create function to handle new user signup with Google OAuth data create function public.handle_new_user() returns trigger language plpgsql security definer set search_path = public as $$ begin insert into public.profiles ( id, email, first_name, last_name, avatar_url ) values ( new.id, new.email, coalesce( new.raw_user_meta_data->>'first_name', new.raw_user_meta_data->>'given_name', split_part(new.raw_user_meta_data->>'full_name', ' ', 1), 'Anonymous' ), coalesce( new.raw_user_meta_data->>'last_name', new.raw_user_meta_data->>'family_name', array_to_string( array_remove( string_to_array(new.raw_user_meta_data->>'full_name', ' '), split_part(new.raw_user_meta_data->>'full_name', ' ', 1) ), ' ' ), 'User' ), coalesce( new.raw_user_meta_data->>'avatar_url', new.raw_user_meta_data->>'picture', new.raw_user_meta_data->>'avatar', null ) ); return new; exception when others then raise log 'Error in handle_new_user: %', SQLERRM; return new; -- Still return the user even if profile creation fails end; $$; -- Create trigger for new user signup create trigger on_auth_user_created after insert on auth.users for each row execute procedure public.handle_new_user(); -- Set up Storage! insert into storage.buckets (id, name, public) values ('avatars', 'avatars',true); -- Set up access controls for storage. -- See https://supabase.com/docs/guides/storage#policy-examples for more details. create policy "Avatar images are publicly accessible." on storage.objects for select using (bucket_id = 'avatars'); create policy "Anyone can upload an avatar." on storage.objects for insert with check (bucket_id = 'avatars'); -- Allow users to upload their own avatar create policy "Users can update their own avatar" on storage.objects for update to authenticated using ( bucket_id = 'avatars' and auth.uid()::text = (storage.foldername(name))[1] ); -- Add updated_at trigger CREATE TRIGGER set_updated_at BEFORE UPDATE ON profiles FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241122141115_add_cascade_on_delete.sql

```sql
-- First, drop existing foreign key constraints ALTER TABLE office DROP CONSTRAINT office_unit_id_fkey; ALTER TABLE program DROP CONSTRAINT program_unit_id_fkey; ALTER TABLE program DROP CONSTRAINT program_office_id_fkey; ALTER TABLE position DROP CONSTRAINT position_nature_of_work_id_fkey; -- Then add them back with ON DELETE CASCADE ALTER TABLE office ADD CONSTRAINT office_unit_id_fkey FOREIGN KEY (unit_id) REFERENCES unit(id) ON DELETE CASCADE; ALTER TABLE program ADD CONSTRAINT program_unit_id_fkey FOREIGN KEY (unit_id) REFERENCES unit(id) ON DELETE CASCADE; ALTER TABLE program ADD CONSTRAINT program_office_id_fkey FOREIGN KEY (office_id) REFERENCES office(id) ON DELETE CASCADE; ALTER TABLE position ADD CONSTRAINT position_nature_of_work_id_fkey FOREIGN KEY (nature_of_work_id) REFERENCES nature_of_work(id) ON DELETE CASCADE;
```

# 20241122170218_add_realtime_tables.sql

```sql
alter publication supabase_realtime add table unit, nature_of_work, office, program, position, employee_status, profiles;
```

# 20241127102744_scope_type.sql

```sql
-- Create scope type CREATE TYPE scope_type AS ENUM ('all', 'office','program', 'unit');
```

# 20241127115411_create_roles_table.sql

```sql
-- Roles table CREATE TABLE roles ( id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, name VARCHAR(100) NOT NULL UNIQUE, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL );
```

# 20241127120413_create_permissions_table.sql

```sql
-- Permissions table CREATE TABLE permissions ( id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, name VARCHAR(100) NOT NULL UNIQUE, description TEXT, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL );
```

# 20241127121741_create_role_permissions_table.sql

```sql
-- Role permissions mapping with scope CREATE TABLE role_permissions ( id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, role_id INTEGER REFERENCES roles(id) ON DELETE CASCADE, permission_id INTEGER REFERENCES permissions(id) ON DELETE CASCADE, scope scope_type NOT NULL DEFAULT 'unit', created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, UNIQUE(role_id, permission_id) );
```

# 20241127121931_create_user_roles_table.sql

```sql
-- User roles mapping (one role per user) CREATE TABLE user_roles ( id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE, role_id INTEGER NOT NULL REFERENCES roles(id) ON DELETE CASCADE, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, UNIQUE(user_id) );
```

# 20241127123124_create_auth_jwt_function.sql

```sql
-- Grant necessary permissions GRANT USAGE ON SCHEMA auth TO postgres, authenticated, anon; GRANT SELECT ON TABLE user_roles TO supabase_auth_admin; GRANT SELECT ON TABLE roles TO supabase_auth_admin; GRANT EXECUTE ON FUNCTION auth.jwt() TO postgres, authenticated, anon; -- Create the JWT function CREATE OR REPLACE FUNCTION auth.jwt() RETURNS jsonb LANGUAGE plpgsql SECURITY DEFINER SET search_path = auth, public AS $$ DECLARE result jsonb; BEGIN SELECT jsonb_build_object( 'role', roles.name, 'role_id', roles.id ) INTO result FROM user_roles JOIN roles ON user_roles.role_id = roles.id WHERE user_roles.user_id = auth.uid(); RETURN COALESCE(result, '{}'::jsonb); END; $$;
```

# 20241127123317_create_permission_check_function.sql

```sql
CREATE OR REPLACE FUNCTION check_permission( required_permission VARCHAR, target_office_id INTEGER DEFAULT NULL, target_unit_id INTEGER DEFAULT NULL, target_program_id INTEGER DEFAULT NULL ) RETURNS BOOLEAN AS $$ DECLARE user_permission_scope scope_type; user_assigned_office_id INTEGER; user_assigned_unit_id INTEGER; user_assigned_program_id INTEGER; permission_exists BOOLEAN; BEGIN -- Get user's scope and IDs SELECT role_permission.scope, profile.office_id, profile.unit_id, profile.program_id, EXISTS ( SELECT 1 FROM role_permissions role_permission_check JOIN permissions permission ON permission.id = role_permission_check.permission_id WHERE role_permission_check.role_id = (auth.jwt()->>'role_id')::integer AND permission.name = required_permission ) INTO user_permission_scope, user_assigned_office_id, user_assigned_unit_id, user_assigned_program_id, permission_exists FROM profiles profile JOIN user_roles user_role ON profile.id = user_role.user_id JOIN role_permissions role_permission ON user_role.role_id = role_permission.role_id JOIN permissions permission ON role_permission.permission_id = permission.id WHERE profile.id = auth.uid() AND permission.name = required_permission; -- No permission found IF NOT permission_exists THEN RETURN FALSE; END IF; -- Check scope access from highest (all) to lowest (unit) RETURN CASE -- All level (highest scope) WHEN user_permission_scope = 'all' THEN TRUE -- Program level WHEN user_permission_scope = 'program' THEN target_program_id IS NULL OR target_program_id = user_assigned_program_id -- Office level WHEN user_permission_scope = 'office' THEN target_office_id IS NULL OR target_office_id = user_assigned_office_id -- Unit level (lowest scope) WHEN user_permission_scope = 'unit' THEN target_unit_id IS NULL OR target_unit_id = user_assigned_unit_id -- Default case ELSE FALSE END; END; $$ LANGUAGE plpgsql SECURITY DEFINER;
```

# 20241127152010_create_user_role_view.sql

```sql
CREATE VIEW user_role_view AS SELECT user_roles.user_id, roles.name as role_name, roles.id as role_id FROM user_roles JOIN roles ON user_roles.role_id = roles.id; CREATE OR REPLACE FUNCTION get_user_role() RETURNS TABLE ( role_name VARCHAR, role_id INTEGER ) LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$ BEGIN RETURN QUERY SELECT roles.name, roles.id FROM user_roles JOIN roles ON user_roles.role_id = roles.id WHERE user_roles.user_id = auth.uid(); END; $$; -- Grant execute permission GRANT EXECUTE ON FUNCTION get_user_role() TO authenticated;
```

# 20241128090943_system_admin_create_insert_function.sql

```sql
-- Create function to check if user is system admin CREATE OR REPLACE FUNCTION is_system_admin() RETURNS BOOLEAN LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$ DECLARE user_role_name VARCHAR; BEGIN -- Get the role name from the JWT SELECT (auth.jwt()->>'role')::VARCHAR INTO user_role_name; -- Check if user has system_admin role RETURN user_role_name = 'system_admin'; END; $$; -- Grant execute permission GRANT EXECUTE ON FUNCTION is_system_admin() TO authenticated;
```

# 20241128091037_RLS_for_unit.sql

```sql
-- Apply RLS policies to each table ALTER TABLE unit ENABLE ROW LEVEL SECURITY; CREATE POLICY "Enable read access for all users on unit" ON unit FOR SELECT TO authenticated USING (true); CREATE POLICY "Enable insert for system admin on unit" ON unit FOR INSERT TO authenticated WITH CHECK (is_system_admin()); CREATE POLICY "Enable update for system admin on unit" ON unit FOR UPDATE TO authenticated USING (is_system_admin()) WITH CHECK (is_system_admin()); CREATE POLICY "Enable delete for system admin on unit" ON unit FOR DELETE TO authenticated USING (is_system_admin());
```

# 20241128091124_RLS_for_office.sql

```sql
ALTER TABLE office ENABLE ROW LEVEL SECURITY; -- Create policies for office table CREATE POLICY "Enable read access for all users on office" ON office FOR SELECT TO authenticated USING (true); CREATE POLICY "Enable insert for system admin on office" ON office FOR INSERT TO authenticated WITH CHECK (is_system_admin()); CREATE POLICY "Enable update for system admin on office" ON office FOR UPDATE TO authenticated USING (is_system_admin()) WITH CHECK (is_system_admin()); CREATE POLICY "Enable delete for system admin on office" ON office FOR DELETE TO authenticated USING (is_system_admin());
```

# 20241128091158_RLS_for_program.sql

```sql
ALTER TABLE program ENABLE ROW LEVEL SECURITY; -- Create policies for program table CREATE POLICY "Enable read access for all users on program" ON program FOR SELECT TO authenticated USING (true); CREATE POLICY "Enable insert for system admin on program" ON program FOR INSERT TO authenticated WITH CHECK (is_system_admin()); CREATE POLICY "Enable update for system admin on program" ON program FOR UPDATE TO authenticated USING (is_system_admin()) WITH CHECK (is_system_admin()); CREATE POLICY "Enable delete for system admin on program" ON program FOR DELETE TO authenticated USING (is_system_admin());
```

# 20241128091248_RLS_for_nature_of_work.sql

```sql
ALTER TABLE nature_of_work ENABLE ROW LEVEL SECURITY; -- Create policies for nature_of_work table CREATE POLICY "Enable read access for all users on nature_of_work" ON nature_of_work FOR SELECT TO authenticated USING (true); CREATE POLICY "Enable insert for system admin on nature_of_work" ON nature_of_work FOR INSERT TO authenticated WITH CHECK (is_system_admin()); CREATE POLICY "Enable update for system admin on nature_of_work" ON nature_of_work FOR UPDATE TO authenticated USING (is_system_admin()) WITH CHECK (is_system_admin()); CREATE POLICY "Enable delete for system admin on nature_of_work" ON nature_of_work FOR DELETE TO authenticated USING (is_system_admin());
```

# 20241128091505_RLS_for_position.sql

```sql
ALTER TABLE position ENABLE ROW LEVEL SECURITY; -- Create policies for position table CREATE POLICY "Enable read access for all users on position" ON position FOR SELECT TO authenticated USING (true); CREATE POLICY "Enable insert for system admin on position" ON position FOR INSERT TO authenticated WITH CHECK (is_system_admin()); CREATE POLICY "Enable update for system admin on position" ON position FOR UPDATE TO authenticated USING (is_system_admin()) WITH CHECK (is_system_admin()); CREATE POLICY "Enable delete for system admin on position" ON position FOR DELETE TO authenticated USING (is_system_admin());
```

# 20241128091542_RLS_for_employee_status.sql

```sql
ALTER TABLE employee_status ENABLE ROW LEVEL SECURITY; CREATE POLICY "Enable read access for all users on employee_status" ON employee_status FOR SELECT TO authenticated USING (true); CREATE POLICY "Enable insert for system admin on employee_status" ON employee_status FOR INSERT TO authenticated WITH CHECK (is_system_admin()); CREATE POLICY "Enable update for system admin on employee_status" ON employee_status FOR UPDATE TO authenticated USING (is_system_admin()) WITH CHECK (is_system_admin()); CREATE POLICY "Enable delete for system admin on employee_status" ON employee_status FOR DELETE TO authenticated USING (is_system_admin());
```

# 20241216163511_create_table_operational_plan.sql

```sql
-- Create operational_plan table CREATE TABLE operational_plan ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), creator_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL, unit_id INTEGER REFERENCES unit(id) ON DELETE CASCADE NOT NULL, office_id INTEGER REFERENCES office(id) ON DELETE CASCADE, program_id INTEGER REFERENCES program(id) ON DELETE CASCADE, title TEXT NOT NULL, implementing_unit TEXT NOT NULL, review_by VARCHAR(255), reviewer_position VARCHAR(255), approve_by VARCHAR(255), approver_position VARCHAR(255), created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Create indexes for foreign keys and commonly searched fields CREATE INDEX idx_operational_plan_unit_id ON operational_plan(unit_id); CREATE INDEX idx_operational_plan_office_id ON operational_plan(office_id); CREATE INDEX idx_operational_plan_program_id ON operational_plan(program_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON operational_plan FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241218095055_create_op_header_table.sql

```sql
-- Create op_header table CREATE TABLE op_header ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), operational_plan_id UUID REFERENCES operational_plan(id) ON DELETE CASCADE NOT NULL, position INTEGER NOT NULL, title TEXT NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Add indexes for better query performance CREATE INDEX idx_op_header_operational_plan_id ON op_header(operational_plan_id); CREATE INDEX idx_op_header_position ON op_header(position, operational_plan_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON op_header FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241218095410_create_op_annual_plan.sql

```sql
-- Create annual_plan table CREATE TABLE op_annual_plan ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), op_header_id UUID REFERENCES op_header(id) ON DELETE CASCADE NOT NULL, description TEXT NOT NULL, position INTEGER NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Add indexes for better query performance CREATE INDEX idx_op_annual_plan_op_header_id ON op_annual_plan(op_header_id); CREATE INDEX idx_op_annual_plan_position ON op_annual_plan(position, op_header_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON op_annual_plan FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241221025054_create_op_activities_table.sql

```sql
-- Create input type enum CREATE TYPE input_type_op AS ENUM ('percentage', 'number', 'ratio', 'text'); -- Create activities table CREATE TABLE op_activity ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), op_annual_plan_id UUID REFERENCES op_annual_plan(id) ON DELETE CASCADE NOT NULL, activity TEXT NOT NULL, input_type input_type_op NOT NULL DEFAULT 'text', performance_indicator TEXT NOT NULL, former_state TEXT NOT NULL, q1_target TEXT, q2_target TEXT, q3_target TEXT, q4_target TEXT, total TEXT, responsible_officer_unit TEXT NOT NULL, total_budgetary_requirements TEXT NOT NULL, position INTEGER NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Add indexes for better query performance CREATE INDEX idx_op_activity_annual_plan_id ON op_activity(op_annual_plan_id); CREATE INDEX idx_op_activity_position ON op_activity(position, op_annual_plan_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON op_activity FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241223034318_create_ipcr_table.sql

```sql
-- Create status enum type if it doesn't exist already CREATE TYPE ipcr_status AS ENUM ('draft', 'submitted', 'reviewing', 'revision', 'approved'); -- Create ipcr table CREATE TABLE ipcr ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), title VARCHAR(255) NOT NULL, status ipcr_status DEFAULT 'draft' NOT NULL, head_of_operating_unit VARCHAR(255), immediate_supervisor VARCHAR(255), program_chair VARCHAR(255), dean VARCHAR(255), owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE, unit_id INTEGER REFERENCES unit(id) ON DELETE CASCADE, office_id INTEGER REFERENCES office(id) ON DELETE CASCADE, program_id INTEGER REFERENCES program(id) ON DELETE CASCADE, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Create indexes for foreign keys and common query patterns CREATE INDEX idx_ipcr_owner ON ipcr(owner_id); CREATE INDEX idx_ipcr_unit ON ipcr(unit_id); CREATE INDEX idx_ipcr_office ON ipcr(office_id); CREATE INDEX idx_ipcr_program ON ipcr(program_id); CREATE INDEX idx_ipcr_status ON ipcr(status); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON ipcr FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241223075628_create_ipcr_function_table.sql

```sql
-- Create ipcr_function table CREATE TABLE ipcr_function ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), title VARCHAR(255) NOT NULL, percentage integer NOT NULL, ipcr_id UUID REFERENCES ipcr(id) ON DELETE CASCADE NOT NULL, position INTEGER NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, UNIQUE(ipcr_id, title) ); -- Add index for better query performance when ordering by position CREATE INDEX idx_ipcr_function_position ON ipcr_function(position, ipcr_id); -- Add index for foreign key CREATE INDEX idx_ipcr_function_ipcr_id ON ipcr_function(ipcr_id); -- Add trigger for updating the updated_at timestamp CREATE TRIGGER set_updated_at BEFORE UPDATE ON ipcr_function FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241223175944_create_ipcr_category_table.sql

```sql
-- Create ipcr_function_category table CREATE TABLE ipcr_function_category ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), ipcr_function_id UUID REFERENCES ipcr_function(id) ON DELETE CASCADE NOT NULL, category VARCHAR(255) NOT NULL, unit NUMERIC(4,2), immediate_supervisor_id UUID REFERENCES auth.users(id), position SMALLINT NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, UNIQUE(category, ipcr_function_id) ); -- Add index for foreign key references and position ordering CREATE INDEX idx_ipcr_function_category_function_id ON ipcr_function_category(ipcr_function_id); CREATE INDEX idx_ipcr_function_category_position ON ipcr_function_category(position, ipcr_function_id); CREATE INDEX idx_ipcr_function_category_supervisor_id ON ipcr_function_category(immediate_supervisor_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON ipcr_function_category FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241224134050_create_ipcr_sub_category_table.sql

```sql
-- Create ipcr_function_sub_category table CREATE TABLE ipcr_function_sub_category ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), ipcr_function_category_id UUID REFERENCES ipcr_function_category(id) ON DELETE CASCADE NOT NULL, sub_category VARCHAR(255) NOT NULL, position INTEGER NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Add indexes for better query performance CREATE INDEX idx_ipcr_function_sub_category_category_id ON ipcr_function_sub_category(ipcr_function_category_id); CREATE INDEX idx_ipcr_function_sub_category_position ON ipcr_function_sub_category(position, ipcr_function_category_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON ipcr_function_sub_category FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241224140105_create_ipcr_indicator_table.sql

```sql
-- Create status enum type CREATE TYPE ipcr_indicator_status AS ENUM ('draft', 'submitted', 'reviewing','revision', 'approved'); -- remove indicator date -- Create ipcr_indicator table CREATE TABLE ipcr_indicator ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), status ipcr_indicator_status DEFAULT 'draft' NOT NULL, ipcr_function_id UUID REFERENCES ipcr_function(id) ON DELETE CASCADE, ipcr_function_sub_category_id UUID REFERENCES ipcr_function_sub_category(id) ON DELETE CASCADE, ipcr_function_category_id UUID REFERENCES ipcr_function_category(id) ON DELETE CASCADE, final_output TEXT NOT NULL, success_indicator TEXT NOT NULL, actual_accomplishments TEXT, accomplishment_date DATE, op_activity_id UUID REFERENCES op_activity(id) ON DELETE SET NULL NOT NULL, quality_rating NUMERIC(3,2), efficiency_rating NUMERIC(3,2), timeliness_rating NUMERIC(3,2), average_rating NUMERIC(3,2), remarks TEXT, position SMALLINT NOT NULL, immediate_supervisor_id UUID REFERENCES auth.users(id) ON DELETE SET NULL, units NUMERIC(4,2), created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Add indexes for foreign key relationships and common query patterns CREATE INDEX idx_ipcr_indicator_function_id ON ipcr_indicator(ipcr_function_id); CREATE INDEX idx_ipcr_indicator_sub_category_id ON ipcr_indicator(ipcr_function_sub_category_id); CREATE INDEX idx_ipcr_indicator_category_id ON ipcr_indicator(ipcr_function_category_id); CREATE INDEX idx_ipcr_indicator_op_activity_id ON ipcr_indicator(op_activity_id); CREATE INDEX idx_ipcr_indicator_immediate_supervisor ON ipcr_indicator(immediate_supervisor_id); -- Add composite index for position ordering within categories CREATE INDEX idx_ipcr_indicator_position ON ipcr_indicator(position, ipcr_function_category_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON ipcr_indicator FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241224185423_view_op_activities.sql

```sql
-- Drop existing view if it exists DROP VIEW IF EXISTS operational_plan_activities; -- Create view for operational plan activities CREATE OR REPLACE VIEW operational_plan_activities AS SELECT op.id AS operational_plan_id, op.title AS operational_plan_title, op.implementing_unit, op.creator_id, op.unit_id, op.office_id, op.program_id, op.review_by, op.reviewer_position, op.approve_by, op.approver_position, h.id AS header_id, h.title AS header_title, h.position AS header_position, ap.id AS annual_plan_id, ap.description AS annual_plan_description, ap.position AS annual_plan_position, act.id AS activity_id, act.activity, act.input_type, act.performance_indicator, act.former_state, act.q1_target, act.q2_target, act.q3_target, act.q4_target, act.total, act.responsible_officer_unit, act.total_budgetary_requirements, act.position AS activity_position, act.created_at AS activity_created_at, act.updated_at AS activity_updated_at FROM operational_plan op LEFT JOIN op_header h ON op.id = h.operational_plan_id LEFT JOIN op_annual_plan ap ON h.id = ap.op_header_id LEFT JOIN op_activity act ON ap.id = act.op_annual_plan_id ORDER BY op.id, h.position, ap.position, act.position; -- Grant select permission to authenticated users GRANT SELECT ON operational_plan_activities TO authenticated;
```

# 20241226123705_create_ipcr_submit_checker.sql

```sql
-- First create the type if it doesn't exist DROP TYPE IF EXISTS validation_result CASCADE; CREATE TYPE validation_result AS ( is_valid boolean, validation_message text ); -- Create the validation function CREATE OR REPLACE FUNCTION validate_ipcr(p_ipcr_id UUID) RETURNS validation_result LANGUAGE plpgsql AS $$ DECLARE result validation_result; invalid_function RECORD; invalid_indicator RECORD; BEGIN -- Check if IPCR has at least one function IF NOT EXISTS ( SELECT 1 FROM ipcr_function WHERE ipcr_id = p_ipcr_id ) THEN result := (false, 'IPCR must have at least one function'); RETURN result; END IF; -- Check if each function has at least one indicator (from function, category or subcategory) SELECT f.id, f.title INTO invalid_function FROM ipcr_function f WHERE f.ipcr_id = p_ipcr_id AND NOT EXISTS ( -- Check direct function indicators SELECT 1 FROM ipcr_indicator i WHERE i.ipcr_function_id = f.id UNION ALL -- Check category indicators SELECT 1 FROM ipcr_function_category fc JOIN ipcr_indicator i ON i.ipcr_function_category_id = fc.id WHERE fc.ipcr_function_id = f.id UNION ALL -- Check subcategory indicators SELECT 1 FROM ipcr_function_category fc JOIN ipcr_function_sub_category fsc ON fsc.ipcr_function_category_id = fc.id JOIN ipcr_indicator i ON i.ipcr_function_sub_category_id = fsc.id WHERE fc.ipcr_function_id = f.id ) LIMIT 1; IF FOUND THEN result := (false, format('Function "%s": No indicators found at any level', invalid_function.title)); RETURN result; END IF; -- Check basic requirements for all indicators SELECT CASE WHEN i.final_output IS NULL THEN 'Missing Final Output' WHEN i.success_indicator IS NULL THEN 'Missing Success Indicator' WHEN i.op_activity_id IS NULL THEN 'Missing Operational Plan Activity' END as missing_field, COALESCE(f.title, fc.category, fsc.sub_category) as parent_name INTO invalid_indicator FROM ipcr_indicator i LEFT JOIN ipcr_function f ON f.id = i.ipcr_function_id LEFT JOIN ipcr_function_category fc ON fc.id = i.ipcr_function_category_id LEFT JOIN ipcr_function_sub_category fsc ON fsc.id = i.ipcr_function_sub_category_id WHERE (f.ipcr_id = p_ipcr_id OR EXISTS(SELECT 1 FROM ipcr_function parent_f WHERE parent_f.ipcr_id = p_ipcr_id AND fc.ipcr_function_id = parent_f.id)) AND ( i.final_output IS NULL OR i.success_indicator IS NULL OR i.op_activity_id IS NULL ) LIMIT 1; IF FOUND THEN result := (false, format('In %s: %s', invalid_indicator.parent_name, invalid_indicator.missing_field)); RETURN result; END IF; -- Special check for indicators directly under function SELECT CASE WHEN i.immediate_supervisor_id IS NULL THEN 'Missing Immediate Supervisor' WHEN i.units IS NULL THEN 'Missing Units' END as missing_field, f.title as function_title INTO invalid_indicator FROM ipcr_indicator i JOIN ipcr_function f ON f.id = i.ipcr_function_id WHERE f.ipcr_id = p_ipcr_id AND i.ipcr_function_category_id IS NULL AND i.ipcr_function_sub_category_id IS NULL AND ( i.immediate_supervisor_id IS NULL OR i.units IS NULL ) LIMIT 1; IF FOUND THEN result := (false, format('Direct indicator under function "%s": %s', invalid_indicator.function_title, invalid_indicator.missing_field)); RETURN result; END IF; -- If we get here, everything is valid result := (true, 'IPCR is complete and valid'); RETURN result; END; $$;
```

# 20241226155655_create_evidence_storage.sql

```sql
-- Create a new storage bucket for evidence files insert into storage.buckets (id, name, public) values ('indicator_evidence', 'indicator_evidence', false); -- CREATE POLICY "User can read their own evidence files" -- ON storage.objects FOR SELECT USING ( -- bucket_id = 'indicator_evidence' -- AND auth.uid()::text = (storage.foldername(name))[1] -- ); CREATE POLICY "User can upload their own evidence files" ON storage.objects FOR INSERT WITH CHECK ( bucket_id = 'indicator_evidence' AND auth.uid()::text = (storage.foldername(name))[1] );
```

# 20241226155730_create_evidence_table.sql

```sql
-- Create evidence table CREATE TABLE ipcr_indicator_evidence ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), ipcr_indicator_id UUID REFERENCES ipcr_indicator(id) ON DELETE CASCADE NOT NULL, file_path TEXT NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Create index for better query performance CREATE INDEX idx_ipcr_indicator_evidence_indicator_id ON ipcr_indicator_evidence(ipcr_indicator_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON ipcr_indicator_evidence FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241229162216_create_accomplishment_report_table.sql

```sql
-- Create status enum type if it doesn't exist CREATE TYPE accomplishment_status AS ENUM ('draft', 'submitted', 'reviewing', 'revision', 'approved'); -- Create accomplishment_report table CREATE TABLE accomplishment_report ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), using_template BOOLEAN DEFAULT FALSE NOT NULL, implementing_unit TEXT NOT NULL, title VARCHAR(255) NOT NULL, head_of_operating_unit VARCHAR(255) NOT NULL, status accomplishment_status DEFAULT 'draft' NOT NULL, owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL, unit_id INTEGER REFERENCES unit(id) ON DELETE CASCADE, office_id INTEGER REFERENCES office(id) ON DELETE CASCADE, program_id INTEGER REFERENCES program(id) ON DELETE CASCADE, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Create indexes for foreign keys and common query patterns CREATE INDEX idx_accomplishment_report_owner ON accomplishment_report(owner_id); CREATE INDEX idx_accomplishment_report_unit ON accomplishment_report(unit_id); CREATE INDEX idx_accomplishment_report_office ON accomplishment_report(office_id); CREATE INDEX idx_accomplishment_report_program ON accomplishment_report(program_id); CREATE INDEX idx_accomplishment_report_status ON accomplishment_report(status); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON accomplishment_report FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241229170523_create_accomplishment_project_program.sql

```sql
-- Create accomplishment_program_project table CREATE TABLE accomplishment_program_project ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), is_included BOOLEAN DEFAULT TRUE NOT NULL, accomplishment_report_id UUID REFERENCES accomplishment_report(id) ON DELETE CASCADE NOT NULL, program_project VARCHAR(255) NOT NULL, position SMALLINT NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, UNIQUE(program_project, accomplishment_report_id) ); -- Add indexes for better query performance CREATE INDEX idx_accomplishment_program_project_report_id ON accomplishment_program_project(accomplishment_report_id); CREATE INDEX idx_accomplishment_program_project_position ON accomplishment_program_project(position, accomplishment_report_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON accomplishment_program_project FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241229171016_create_accomplishment_metrics.sql

```sql
-- Create accomplishment_metrics table CREATE TABLE accomplishment_metrics ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), is_included BOOLEAN DEFAULT TRUE NOT NULL, accomplishment_program_project_id UUID REFERENCES accomplishment_program_project(id) ON DELETE CASCADE NOT NULL, metrics TEXT NOT NULL, former_state TEXT, annual_target TEXT, quarter_1_accomplishment TEXT, quarter_2_accomplishment TEXT, quarter_3_accomplishment TEXT, quarter_4_accomplishment TEXT, total_accomplishment TEXT, variance TEXT, remarks TEXT, position SMALLINT NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Add indexes for better query performance CREATE INDEX idx_accomplishment_metrics_program_project_id ON accomplishment_metrics(accomplishment_program_project_id); CREATE INDEX idx_accomplishment_metrics_position ON accomplishment_metrics(position, accomplishment_program_project_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON accomplishment_metrics FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20250105163140_create_table_accomplishment_report_template.sql

```sql
-- Create accomplishment_report_template table CREATE TABLE accomplishment_report_template ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), is_published BOOLEAN DEFAULT FALSE NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON accomplishment_report_template FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20250105163158_create_table_accomplishment_program_project_template.sql

```sql
-- Create accomplishment_template_program_project table CREATE TABLE accomplishment_template_program_project ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), accomplishment_report_template_id UUID REFERENCES accomplishment_report_template(id) ON DELETE CASCADE NOT NULL, position INTEGER NOT NULL, program_project TEXT NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Add indexes for better query performance CREATE INDEX idx_accomplishment_template_program_project_template_id ON accomplishment_template_program_project(accomplishment_report_template_id); CREATE INDEX idx_accomplishment_template_program_project_position ON accomplishment_template_program_project(position, accomplishment_report_template_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON accomplishment_template_program_project FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20250105163300_create_table_accomplishment_metrics_template.sql

```sql
-- Create accomplishment_template_metrics table CREATE TABLE accomplishment_template_metrics ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), accomplishment_template_program_project_id UUID REFERENCES accomplishment_template_program_project(id) ON DELETE CASCADE NOT NULL, metrics TEXT NOT NULL, former_state TEXT, annual_target TEXT, position INTEGER NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Add indexes for better query performance CREATE INDEX idx_accomplishment_template_metrics_program_project_id ON accomplishment_template_metrics(accomplishment_template_program_project_id); CREATE INDEX idx_accomplishment_template_metrics_position ON accomplishment_template_metrics(position, accomplishment_template_program_project_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON accomplishment_template_metrics FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20250106143114_create_make_accomplishment_report_function.sql

```sql
CREATE OR REPLACE FUNCTION create_accomplishment_report_from_template( p_implementing_unit TEXT, p_title TEXT, p_head_of_operating_unit TEXT, -- Added new parameter p_owner_id UUID, p_unit_id INTEGER, p_office_id INTEGER DEFAULT NULL, p_program_id INTEGER DEFAULT NULL ) RETURNS UUID LANGUAGE plpgsql AS $$ DECLARE template_id UUID; new_report_id UUID; template_program RECORD; new_program_id UUID; BEGIN -- Get published template ID SELECT id INTO template_id FROM accomplishment_report_template WHERE is_published = TRUE LIMIT 1; IF template_id IS NULL THEN RAISE EXCEPTION 'No published template found'; END IF; -- Create new report INSERT INTO accomplishment_report ( using_template, implementing_unit, title, head_of_operating_unit, -- Added new field owner_id, unit_id, office_id, program_id ) VALUES ( TRUE, p_implementing_unit, p_title, p_head_of_operating_unit, -- Added new value p_owner_id, p_unit_id, p_office_id, p_program_id ) RETURNING id INTO new_report_id; -- Copy programs and metrics FOR template_program IN SELECT * FROM accomplishment_template_program_project WHERE accomplishment_report_template_id = template_id ORDER BY position LOOP INSERT INTO accomplishment_program_project ( accomplishment_report_id, program_project, position ) VALUES ( new_report_id, template_program.program_project, template_program.position ) RETURNING id INTO new_program_id; INSERT INTO accomplishment_metrics ( accomplishment_program_project_id, metrics, former_state, annual_target, position ) SELECT new_program_id, metrics, former_state, annual_target, position FROM accomplishment_template_metrics WHERE accomplishment_template_program_project_id = template_program.id; END LOOP; RETURN new_report_id; END; $$;
```

# 20250107155709_create_toggle_is_included_metrics.sql

```sql
CREATE OR REPLACE FUNCTION toggle_metrics_inclusion(metrics_id uuid) RETURNS TABLE ( id uuid, is_included boolean, accomplishment_program_project_id uuid, metrics text, former_state text, annual_target text, quarter_1_accomplishment text, quarter_2_accomplishment text, quarter_3_accomplishment text, quarter_4_accomplishment text, total_accomplishment text, variance text, remarks text, "position" smallint, created_at timestamptz, updated_at timestamptz ) LANGUAGE plpgsql SECURITY DEFINER AS $$ DECLARE program_project_included boolean; BEGIN -- Check if the parent program/project is included SELECT app.is_included INTO program_project_included FROM accomplishment_metrics am JOIN accomplishment_program_project app ON app.id = am.accomplishment_program_project_id WHERE am.id = toggle_metrics_inclusion.metrics_id; -- If program/project is not included, raise an error IF NOT program_project_included THEN RAISE EXCEPTION 'Cannot include metric: Parent program/project is not included. Please include the program/project first.'; END IF; -- If we get here, we can proceed with the toggle RETURN QUERY UPDATE accomplishment_metrics am SET is_included = NOT am.is_included WHERE am.id = toggle_metrics_inclusion.metrics_id RETURNING am.id, am.is_included, am.accomplishment_program_project_id, am.metrics, am.former_state, am.annual_target, am.quarter_1_accomplishment, am.quarter_2_accomplishment, am.quarter_3_accomplishment, am.quarter_4_accomplishment, am.total_accomplishment, am.variance, am.remarks, am."position", am.created_at, am.updated_at; END; $$; -- Grant execute permission to authenticated users GRANT EXECUTE ON FUNCTION toggle_metrics_inclusion TO authenticated;
```

# 20250107163007_create_toggle_is_included_program_project.sql

```sql
CREATE OR REPLACE FUNCTION toggle_program_project_inclusion(program_project_id uuid) RETURNS TABLE ( id uuid, is_included boolean, accomplishment_report_id uuid, program_project varchar(255), "position" smallint, created_at timestamptz, updated_at timestamptz ) LANGUAGE plpgsql SECURITY DEFINER AS $$ DECLARE new_is_included boolean; BEGIN -- First get the current state to determine what to toggle to SELECT NOT is_included INTO new_is_included FROM accomplishment_program_project WHERE id = program_project_id; -- Update all related metrics to match the new state UPDATE accomplishment_metrics am SET is_included = new_is_included WHERE am.accomplishment_program_project_id = toggle_program_project_inclusion.program_project_id; -- Update and return the program/project RETURN QUERY UPDATE accomplishment_program_project app SET is_included = new_is_included WHERE app.id = toggle_program_project_inclusion.program_project_id RETURNING app.id, app.is_included, app.accomplishment_report_id, app.program_project, app."position", app.created_at, app.updated_at; END; $$; -- Grant execute permission to authenticated users GRANT EXECUTE ON FUNCTION toggle_program_project_inclusion TO authenticated;
```

# 20250110172658_create_view_ipcr_supervisors.sql

```sql
CREATE OR REPLACE VIEW ipcr_supervisors AS WITH combined_supervisors AS ( -- Get supervisors from categories and indicators SELECT DISTINCT f.ipcr_id, fc.immediate_supervisor_id FROM ipcr_function_category fc JOIN ipcr_function f ON f.id = fc.ipcr_function_id WHERE fc.immediate_supervisor_id IS NOT NULL UNION SELECT DISTINCT f.ipcr_id, i.immediate_supervisor_id FROM ipcr_indicator i JOIN ipcr_function f ON f.id = i.ipcr_function_id WHERE i.immediate_supervisor_id IS NOT NULL ) SELECT DISTINCT ON (cs.ipcr_id, cs.immediate_supervisor_id) cs.ipcr_id, cs.immediate_supervisor_id as id, p.first_name || ' ' || CASE WHEN p.middle_name IS NOT NULL AND p.middle_name != '' THEN p.middle_name || ' ' ELSE '' END || p.last_name as full_name, pos.name as position FROM combined_supervisors cs JOIN profiles p ON p.id = cs.immediate_supervisor_id LEFT JOIN position pos ON pos.id = p.position_id ORDER BY cs.ipcr_id, cs.immediate_supervisor_id, full_name; -- Grant necessary permissions GRANT SELECT ON ipcr_supervisors TO authenticated;
```

# 20250118150916_alter_accomplishment_metric_add_type.sql

```sql
-- Create input type enum CREATE TYPE input_type AS ENUM ('percentage', 'number', 'ratio', 'text'); -- Add input_type column to accomplishment_metrics ALTER TABLE accomplishment_metrics ADD COLUMN input_type input_type NOT NULL DEFAULT 'text';
```

