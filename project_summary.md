# migrations/20241116152556_create_table_unit.sql

```sql
-- Create the function for updating timestamps CREATE OR REPLACE FUNCTION fn_set_updated_at() RETURNS TRIGGER AS $$ BEGIN NEW.updated_at = TIMEZONE('utc'::text, NOW()); RETURN NEW; END; $$ LANGUAGE plpgsql; -- Create the unit table CREATE TABLE unit ( id INTEGER GENERATED BY DEFAULT AS IDENTITY NOT NULL PRIMARY KEY, code VARCHAR(50) NOT NULL UNIQUE, name TEXT NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Create index on commonly searched columns CREATE INDEX idx_unit_code ON unit(code); -- Add updated_at trigger CREATE TRIGGER set_updated_at BEFORE UPDATE ON unit FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# migrations/20241116153626_create_table_nature_of_work.sql

```sql
-- create table CREATE TABLE nature_of_work ( id INTEGER GENERATED BY DEFAULT AS IDENTITY NOT NULL PRIMARY KEY, type VARCHAR(100) NOT NULL UNIQUE, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Add updated_at trigger CREATE TRIGGER set_updated_at BEFORE UPDATE ON nature_of_work FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# migrations/20241116155829_create_table_office.sql

```sql
CREATE TABLE office ( id INTEGER GENERATED BY DEFAULT AS IDENTITY NOT NULL PRIMARY KEY, unit_id INTEGER NOT NULL REFERENCES unit(id), code VARCHAR(50) NOT NULL UNIQUE, name VARCHAR(200) NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Create index for foreign key CREATE INDEX idx_office_unit_id ON office(unit_id); -- Add updated_at trigger CREATE TRIGGER set_updated_at BEFORE UPDATE ON office FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# migrations/20241116160732_create_table_program.sql

```sql
CREATE TABLE program ( id INTEGER GENERATED BY DEFAULT AS IDENTITY NOT NULL PRIMARY KEY, unit_id INTEGER NOT NULL REFERENCES unit(id), office_id INTEGER NOT NULL REFERENCES office(id), name TEXT NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Create indexes for foreign keys CREATE INDEX idx_program_unit_id ON program(unit_id); CREATE INDEX idx_program_office_id ON program(office_id); -- Add updated_at trigger CREATE TRIGGER set_updated_at BEFORE UPDATE ON program FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# migrations/20241116161506_create_table_position.sql

```sql
CREATE TABLE position ( id INTEGER GENERATED BY DEFAULT AS IDENTITY NOT NULL PRIMARY KEY, nature_of_work_id INTEGER NOT NULL REFERENCES nature_of_work(id), name VARCHAR(100) NOT NULL UNIQUE, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Create index for foreign key CREATE INDEX idx_position_nature_of_work_id ON position(nature_of_work_id); -- Add updated_at trigger CREATE TRIGGER set_updated_at BEFORE UPDATE ON position FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# migrations/20241116161733_create_table_employee_status.sql

```sql
-- create table CREATE TABLE employee_status ( id INTEGER GENERATED BY DEFAULT AS IDENTITY NOT NULL PRIMARY KEY, type VARCHAR(100) NOT NULL UNIQUE, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Add updated_at trigger CREATE TRIGGER set_updated_at BEFORE UPDATE ON employee_status FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# migrations/20241116162523_create_table_profile.sql

```sql
-- Create a table for public profiles create table profiles ( id uuid references auth.users on delete cascade not null primary key, updated_at timestamp with time zone default timezone('utc'::text, now()), employee_id varchar(50) unique, email varchar(255) unique, first_name text, middle_name text, last_name text, avatar_url text, unit_id integer references unit(id), nature_of_work_id integer references nature_of_work(id), office_id integer references office(id), program_id integer references program(id), position_id integer references position(id), employee_status_id integer references employee_status(id), created_at timestamp with time zone default timezone('utc'::text, now()) ); -- Set up Row Level Security (RLS) alter table profiles enable row level security; create policy "Public profiles are viewable by everyone." on profiles for select using (true); create policy "Users can insert their own profile." on profiles for insert with check ((select auth.uid()) = id); create policy "Users can update own profile." on profiles for update using ((select auth.uid()) = id); -- Create function to handle new user signup with Google OAuth data create function public.handle_new_user() returns trigger language plpgsql security definer set search_path = public as $$ begin insert into public.profiles ( id, email, first_name, last_name, avatar_url ) values ( new.id, new.email, coalesce( new.raw_user_meta_data->>'first_name', new.raw_user_meta_data->>'given_name', split_part(new.raw_user_meta_data->>'full_name', ' ', 1), 'Anonymous' ), coalesce( new.raw_user_meta_data->>'last_name', new.raw_user_meta_data->>'family_name', array_to_string( array_remove( string_to_array(new.raw_user_meta_data->>'full_name', ' '), split_part(new.raw_user_meta_data->>'full_name', ' ', 1) ), ' ' ), 'User' ), coalesce( new.raw_user_meta_data->>'avatar_url', new.raw_user_meta_data->>'picture', new.raw_user_meta_data->>'avatar', null ) ); return new; exception when others then raise log 'Error in handle_new_user: %', SQLERRM; return new; -- Still return the user even if profile creation fails end; $$; -- Create trigger for new user signup create trigger on_auth_user_created after insert on auth.users for each row execute procedure public.handle_new_user(); -- Set up Storage! insert into storage.buckets (id, name, public) values ('avatars', 'avatars',true); -- Set up access controls for storage. -- See https://supabase.com/docs/guides/storage#policy-examples for more details. create policy "Avatar images are publicly accessible." on storage.objects for select using (bucket_id = 'avatars'); create policy "Anyone can upload an avatar." on storage.objects for insert with check (bucket_id = 'avatars'); -- Allow users to upload their own avatar create policy "Users can update their own avatar" on storage.objects for update to authenticated using ( bucket_id = 'avatars' and auth.uid()::text = (storage.foldername(name))[1] ); -- Add updated_at trigger CREATE TRIGGER set_updated_at BEFORE UPDATE ON profiles FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# migrations/20241122141115_add_cascade_on_delete.sql

```sql
-- First, drop existing foreign key constraints ALTER TABLE office DROP CONSTRAINT office_unit_id_fkey; ALTER TABLE program DROP CONSTRAINT program_unit_id_fkey; ALTER TABLE program DROP CONSTRAINT program_office_id_fkey; ALTER TABLE position DROP CONSTRAINT position_nature_of_work_id_fkey; -- Then add them back with ON DELETE CASCADE ALTER TABLE office ADD CONSTRAINT office_unit_id_fkey FOREIGN KEY (unit_id) REFERENCES unit(id) ON DELETE CASCADE; ALTER TABLE program ADD CONSTRAINT program_unit_id_fkey FOREIGN KEY (unit_id) REFERENCES unit(id) ON DELETE CASCADE; ALTER TABLE program ADD CONSTRAINT program_office_id_fkey FOREIGN KEY (office_id) REFERENCES office(id) ON DELETE CASCADE; ALTER TABLE position ADD CONSTRAINT position_nature_of_work_id_fkey FOREIGN KEY (nature_of_work_id) REFERENCES nature_of_work(id) ON DELETE CASCADE;
```

# migrations/20241122170218_add_realtime_tables.sql

```sql
alter publication supabase_realtime add table unit, nature_of_work, office, program, position, employee_status, profiles;
```

# migrations/20241127102744_scope_type.sql

```sql
-- Create scope type CREATE TYPE scope_type AS ENUM ('all', 'office','program', 'unit');
```

# migrations/20241127115411_create_roles_table.sql

```sql
-- Roles table CREATE TABLE roles ( id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, name VARCHAR(100) NOT NULL UNIQUE, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL );
```

# migrations/20241127120413_create_permissions_table.sql

```sql
-- Permissions table CREATE TABLE permissions ( id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, name VARCHAR(100) NOT NULL UNIQUE, description TEXT, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL );
```

# migrations/20241127121741_create_role_permissions_table.sql

```sql
-- Role permissions mapping with scope CREATE TABLE role_permissions ( id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, role_id INTEGER REFERENCES roles(id) ON DELETE CASCADE, permission_id INTEGER REFERENCES permissions(id) ON DELETE CASCADE, scope scope_type NOT NULL DEFAULT 'unit', created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, UNIQUE(role_id, permission_id) );
```

# migrations/20241127121931_create_user_roles_table.sql

```sql
-- User roles mapping (one role per user) CREATE TABLE user_roles ( id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE, role_id INTEGER NOT NULL REFERENCES roles(id) ON DELETE CASCADE, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, UNIQUE(user_id) );
```

# migrations/20241127123124_create_auth_jwt_function.sql

```sql
-- Grant necessary permissions GRANT USAGE ON SCHEMA auth TO postgres, authenticated, anon; GRANT SELECT ON TABLE user_roles TO supabase_auth_admin; GRANT SELECT ON TABLE roles TO supabase_auth_admin; GRANT EXECUTE ON FUNCTION auth.jwt() TO postgres, authenticated, anon; -- Create the JWT function CREATE OR REPLACE FUNCTION auth.jwt() RETURNS jsonb LANGUAGE plpgsql SECURITY DEFINER SET search_path = auth, public AS $$ DECLARE result jsonb; BEGIN SELECT jsonb_build_object( 'role', roles.name, 'role_id', roles.id ) INTO result FROM user_roles JOIN roles ON user_roles.role_id = roles.id WHERE user_roles.user_id = auth.uid(); RETURN COALESCE(result, '{}'::jsonb); END; $$;
```

# migrations/20241127123317_create_permission_check_function.sql

```sql
CREATE OR REPLACE FUNCTION check_permission( required_permission VARCHAR, target_office_id INTEGER DEFAULT NULL, target_unit_id INTEGER DEFAULT NULL, target_program_id INTEGER DEFAULT NULL ) RETURNS BOOLEAN AS $$ DECLARE user_permission_scope scope_type; user_assigned_office_id INTEGER; user_assigned_unit_id INTEGER; user_assigned_program_id INTEGER; permission_exists BOOLEAN; BEGIN -- Get user's scope and IDs SELECT role_permission.scope, profile.office_id, profile.unit_id, profile.program_id, EXISTS ( SELECT 1 FROM role_permissions role_permission_check JOIN permissions permission ON permission.id = role_permission_check.permission_id WHERE role_permission_check.role_id = (auth.jwt()->>'role_id')::integer AND permission.name = required_permission ) INTO user_permission_scope, user_assigned_office_id, user_assigned_unit_id, user_assigned_program_id, permission_exists FROM profiles profile JOIN user_roles user_role ON profile.id = user_role.user_id JOIN role_permissions role_permission ON user_role.role_id = role_permission.role_id JOIN permissions permission ON role_permission.permission_id = permission.id WHERE profile.id = auth.uid() AND permission.name = required_permission; -- No permission found IF NOT permission_exists THEN RETURN FALSE; END IF; -- Check scope access from highest (all) to lowest (unit) RETURN CASE -- All level (highest scope) WHEN user_permission_scope = 'all' THEN TRUE -- Program level WHEN user_permission_scope = 'program' THEN target_program_id IS NULL OR target_program_id = user_assigned_program_id -- Office level WHEN user_permission_scope = 'office' THEN target_office_id IS NULL OR target_office_id = user_assigned_office_id -- Unit level (lowest scope) WHEN user_permission_scope = 'unit' THEN target_unit_id IS NULL OR target_unit_id = user_assigned_unit_id -- Default case ELSE FALSE END; END; $$ LANGUAGE plpgsql SECURITY DEFINER;
```

# migrations/20241127152010_create_user_role_view.sql

```sql
CREATE VIEW user_role_view AS SELECT user_roles.user_id, roles.name as role_name, roles.id as role_id FROM user_roles JOIN roles ON user_roles.role_id = roles.id; CREATE OR REPLACE FUNCTION get_user_role() RETURNS TABLE ( role_name VARCHAR, role_id INTEGER ) LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$ BEGIN RETURN QUERY SELECT roles.name, roles.id FROM user_roles JOIN roles ON user_roles.role_id = roles.id WHERE user_roles.user_id = auth.uid(); END; $$; -- Grant execute permission GRANT EXECUTE ON FUNCTION get_user_role() TO authenticated;
```

# migrations/20241128090943_system_admin_create_insert_function.sql

```sql
-- Create function to check if user is system admin CREATE OR REPLACE FUNCTION is_system_admin() RETURNS BOOLEAN LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$ DECLARE user_role_name VARCHAR; BEGIN -- Get the role name from the JWT SELECT (auth.jwt()->>'role')::VARCHAR INTO user_role_name; -- Check if user has system_admin role RETURN user_role_name = 'system_admin'; END; $$; -- Grant execute permission GRANT EXECUTE ON FUNCTION is_system_admin() TO authenticated;
```

# migrations/20241128091037_RLS_for_unit.sql

```sql
-- Apply RLS policies to each table ALTER TABLE unit ENABLE ROW LEVEL SECURITY; CREATE POLICY "Enable read access for all users on unit" ON unit FOR SELECT TO authenticated USING (true); CREATE POLICY "Enable insert for system admin on unit" ON unit FOR INSERT TO authenticated WITH CHECK (is_system_admin()); CREATE POLICY "Enable update for system admin on unit" ON unit FOR UPDATE TO authenticated USING (is_system_admin()) WITH CHECK (is_system_admin()); CREATE POLICY "Enable delete for system admin on unit" ON unit FOR DELETE TO authenticated USING (is_system_admin());
```

# migrations/20241128091124_RLS_for_office.sql

```sql
ALTER TABLE office ENABLE ROW LEVEL SECURITY; -- Create policies for office table CREATE POLICY "Enable read access for all users on office" ON office FOR SELECT TO authenticated USING (true); CREATE POLICY "Enable insert for system admin on office" ON office FOR INSERT TO authenticated WITH CHECK (is_system_admin()); CREATE POLICY "Enable update for system admin on office" ON office FOR UPDATE TO authenticated USING (is_system_admin()) WITH CHECK (is_system_admin()); CREATE POLICY "Enable delete for system admin on office" ON office FOR DELETE TO authenticated USING (is_system_admin());
```

# migrations/20241128091158_RLS_for_program.sql

```sql
ALTER TABLE program ENABLE ROW LEVEL SECURITY; -- Create policies for program table CREATE POLICY "Enable read access for all users on program" ON program FOR SELECT TO authenticated USING (true); CREATE POLICY "Enable insert for system admin on program" ON program FOR INSERT TO authenticated WITH CHECK (is_system_admin()); CREATE POLICY "Enable update for system admin on program" ON program FOR UPDATE TO authenticated USING (is_system_admin()) WITH CHECK (is_system_admin()); CREATE POLICY "Enable delete for system admin on program" ON program FOR DELETE TO authenticated USING (is_system_admin());
```

# migrations/20241128091248_RLS_for_nature_of_work.sql

```sql
ALTER TABLE nature_of_work ENABLE ROW LEVEL SECURITY; -- Create policies for nature_of_work table CREATE POLICY "Enable read access for all users on nature_of_work" ON nature_of_work FOR SELECT TO authenticated USING (true); CREATE POLICY "Enable insert for system admin on nature_of_work" ON nature_of_work FOR INSERT TO authenticated WITH CHECK (is_system_admin()); CREATE POLICY "Enable update for system admin on nature_of_work" ON nature_of_work FOR UPDATE TO authenticated USING (is_system_admin()) WITH CHECK (is_system_admin()); CREATE POLICY "Enable delete for system admin on nature_of_work" ON nature_of_work FOR DELETE TO authenticated USING (is_system_admin());
```

# migrations/20241128091505_RLS_for_position.sql

```sql
ALTER TABLE position ENABLE ROW LEVEL SECURITY; -- Create policies for position table CREATE POLICY "Enable read access for all users on position" ON position FOR SELECT TO authenticated USING (true); CREATE POLICY "Enable insert for system admin on position" ON position FOR INSERT TO authenticated WITH CHECK (is_system_admin()); CREATE POLICY "Enable update for system admin on position" ON position FOR UPDATE TO authenticated USING (is_system_admin()) WITH CHECK (is_system_admin()); CREATE POLICY "Enable delete for system admin on position" ON position FOR DELETE TO authenticated USING (is_system_admin());
```

# migrations/20241128091542_RLS_for_employee_status.sql

```sql
ALTER TABLE employee_status ENABLE ROW LEVEL SECURITY; CREATE POLICY "Enable read access for all users on employee_status" ON employee_status FOR SELECT TO authenticated USING (true); CREATE POLICY "Enable insert for system admin on employee_status" ON employee_status FOR INSERT TO authenticated WITH CHECK (is_system_admin()); CREATE POLICY "Enable update for system admin on employee_status" ON employee_status FOR UPDATE TO authenticated USING (is_system_admin()) WITH CHECK (is_system_admin()); CREATE POLICY "Enable delete for system admin on employee_status" ON employee_status FOR DELETE TO authenticated USING (is_system_admin());
```

# migrations/20241204145404_create_ipcr_table.sql

```sql
-- Create status enum type CREATE TYPE ipcr_status AS ENUM ('draft', 'submitted', 'reviewing','revision', 'approved'); -- Create ipcr_teaching table with status CREATE TABLE ipcr ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), title VARCHAR(255) NOT NULL, status ipcr_status DEFAULT 'draft' NOT NULL, owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE, unit_id INTEGER REFERENCES unit(id) ON DELETE CASCADE, office_id INTEGER REFERENCES office(id) ON DELETE CASCADE, program_id INTEGER REFERENCES program(id) ON DELETE CASCADE, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); CREATE TRIGGER set_updated_at BEFORE UPDATE ON ipcr FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# migrations/20241204145806_create_core_function_table.sql

```sql
-- Create core_function table CREATE TABLE core_function ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), name TEXT NOT NULL, ipcr_id UUID REFERENCES ipcr(id) ON DELETE CASCADE NOT NULL, unit NUMERIC(4,2), reviewer_id UUID REFERENCES auth.users(id), position SMALLINT NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, UNIQUE(name, ipcr_id) ); -- Add index for better query performance when ordering by position CREATE INDEX idx_core_function_position ON core_function(position, ipcr_id); -- Trigger for updating the updated_at timestamp CREATE TRIGGER set_updated_at BEFORE UPDATE ON core_function FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# migrations/20241204145908_create_sub_core_function_table.sql

```sql
CREATE TABLE sub_core_function ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), core_function_id UUID REFERENCES core_function(id) ON DELETE CASCADE NOT NULL, name TEXT NOT NULL, position INTEGER NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, UNIQUE(core_function_id, name) ); -- Add an index on position and core_function_id for better performance when sorting CREATE INDEX idx_sub_core_function_position ON sub_core_function(core_function_id, position); CREATE TRIGGER set_updated_at BEFORE UPDATE ON sub_core_function FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# migrations/20241204150054_indicator_table.sql

```sql
-- Create status enum type CREATE TYPE indicator_status AS ENUM ('draft', 'submitted', 'reviewing', 'revision', 'approved'); CREATE TABLE indicator ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), status indicator_status DEFAULT 'draft' NOT NULL, indicator TEXT NOT NULL, accomplishment TEXT, indicator_date DATE, accomplishment_date DATE, quality_rating NUMERIC(3,2), efficiency_rating NUMERIC(3,2), timeliness_rating NUMERIC(3,2), average_rating NUMERIC(3,2), core_function_id UUID REFERENCES core_function(id) ON DELETE CASCADE, sub_core_function_id UUID REFERENCES sub_core_function(id) ON DELETE CASCADE, position INTEGER NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Add an index for better query performance when ordering by position CREATE INDEX idx__indicator_position ON indicator(position, core_function_id); CREATE TRIGGER set_updated_at BEFORE UPDATE ON indicator FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# migrations/20241211113611_create_support_function.sql

```sql
-- Create support_function table CREATE TABLE support_function ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), name TEXT NOT NULL, ipcr_id UUID REFERENCES ipcr(id) ON DELETE CASCADE NOT NULL, unit NUMERIC(4,2), reviewer_id UUID REFERENCES auth.users(id), position SMALLINT NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, UNIQUE(name, ipcr_id) ); -- Add index for better query performance when ordering by position CREATE INDEX idx_support_function_position ON support_function(position, ipcr_id); -- Trigger for updating the updated_at timestamp CREATE TRIGGER set_updated_at BEFORE UPDATE ON support_function FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# migrations/20241211113904_create_sub_support_function.sql

```sql
CREATE TABLE sub_support_function ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), support_function_id UUID REFERENCES support_function(id) ON DELETE CASCADE NOT NULL, name TEXT NOT NULL, position INTEGER NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, UNIQUE(support_function_id, name) ); -- Add an index on position and support_function_id for better performance when sorting CREATE INDEX idx_sub_support_function_position ON sub_support_function(support_function_id, position); CREATE TRIGGER set_updated_at BEFORE UPDATE ON sub_support_function FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# migrations/20241211114649_alter_indicator_add_support_functions.sql

```sql
ALTER TABLE indicator ADD COLUMN support_function_id UUID REFERENCES support_function(id) ON DELETE CASCADE, ADD COLUMN sub_support_function_id UUID REFERENCES sub_support_function(id) ON DELETE CASCADE;
```

# migrations/20241212100049_create_other_function.sql

```sql
-- Create other_function table CREATE TABLE other_function ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), name TEXT NOT NULL, ipcr_id UUID REFERENCES ipcr(id) ON DELETE CASCADE NOT NULL, unit NUMERIC(4,2), reviewer_id UUID REFERENCES auth.users(id), position SMALLINT NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, UNIQUE(name, ipcr_id) ); -- Add index for better query performance when ordering by position CREATE INDEX idx_other_function_position ON other_function(position, ipcr_id); -- Trigger for updating the updated_at timestamp CREATE TRIGGER set_updated_at BEFORE UPDATE ON other_function FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# migrations/20241212100058_create_sub_other_function.sql

```sql
CREATE TABLE sub_other_function ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), other_function_id UUID REFERENCES other_function(id) ON DELETE CASCADE NOT NULL, name TEXT NOT NULL, position INTEGER NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, UNIQUE(other_function_id, name) ); -- Add an index on position and other_function_id for better performance when sorting CREATE INDEX idx_sub_other_function_position ON sub_other_function(other_function_id, position); CREATE TRIGGER set_updated_at BEFORE UPDATE ON sub_other_function FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# migrations/20241212101127_create_subother_function.sql

```sql

```

# package.json

```json
{ "name": "frontend", "version": "0.0.1", "type": "module", "scripts": { "dev": "vite dev", "build": "vite build", "preview": "vite preview", "check": "svelte-kit sync && svelte-check --tsconfig ./tsconfig.json", "check:watch": "svelte-kit sync && svelte-check --tsconfig ./tsconfig.json --watch", "format": "prettier --write .", "lint": "prettier --check . && eslint ." }, "devDependencies": { "@internationalized/date": "^3.6.0", "@sveltejs/adapter-auto": "^3.0.0", "@sveltejs/enhanced-img": "^0.4.1", "@sveltejs/kit": "^2.0.0", "@sveltejs/vite-plugin-svelte": "^4.0.0", "@tailwindcss/aspect-ratio": "^0.4.2", "@tailwindcss/container-queries": "^0.1.1", "@tailwindcss/forms": "^0.5.9", "@tailwindcss/typography": "^0.5.15", "@types/eslint": "^9.6.0", "autoprefixer": "^10.4.20", "bits-ui": "^1.0.0-next.69", "clsx": "^2.1.1", "embla-carousel-svelte": "^8.3.1", "eslint": "^9.7.0", "eslint-config-prettier": "^9.1.0", "eslint-plugin-svelte": "^2.36.0", "formsnap": "^2.0.0-next.1", "globals": "^15.0.0", "lucide-svelte": "^0.460.1", "mode-watcher": "^0.4.1", "prettier": "^3.3.2", "prettier-plugin-svelte": "^3.2.6", "prettier-plugin-tailwindcss": "^0.6.5", "svelte": "^5.0.0", "svelte-check": "^4.0.0", "svelte-radix": "^2.0.1", "svelte-sonner": "^0.3.28", "sveltekit-superforms": "^2.20.0", "tailwind-merge": "^2.5.4", "tailwind-variants": "^0.2.1", "tailwindcss": "^3.4.9", "tailwindcss-animate": "^1.0.7", "typescript": "^5.0.0", "typescript-eslint": "^8.0.0", "vite": "^5.0.3", "zod": "^3.23.8" }, "dependencies": { "@supabase/ssr": "^0.5.1", "@supabase/supabase-js": "^2.46.1", "@tanstack/table-core": "^8.20.5", "@tiptap/core": "^2.10.3", "@tiptap/pm": "^2.10.3", "@tiptap/starter-kit": "^2.10.3", "date-fns": "^4.1.0", "debounce": "^2.2.0", "embla-carousel-autoplay": "^8.3.1", "svelte-dnd-action": "^0.9.52", "title-case": "^4.3.2" } }
```

