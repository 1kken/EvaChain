# 20241116152556_create_table_unit.sql

```sql
-- Create the function for updating timestamps CREATE OR REPLACE FUNCTION fn_set_updated_at() RETURNS TRIGGER AS $$ BEGIN NEW.updated_at = TIMEZONE('utc'::text, NOW()); RETURN NEW; END; $$ LANGUAGE plpgsql; -- Create the unit table CREATE TABLE unit ( id INTEGER GENERATED BY DEFAULT AS IDENTITY NOT NULL PRIMARY KEY, code VARCHAR(50) NOT NULL UNIQUE, name TEXT NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Create index on commonly searched columns CREATE INDEX idx_unit_code ON unit(code); -- Add updated_at trigger CREATE TRIGGER set_updated_at BEFORE UPDATE ON unit FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241116153626_create_table_nature_of_work.sql

```sql
-- create table CREATE TABLE nature_of_work ( id INTEGER GENERATED BY DEFAULT AS IDENTITY NOT NULL PRIMARY KEY, type VARCHAR(100) NOT NULL UNIQUE, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Add updated_at trigger CREATE TRIGGER set_updated_at BEFORE UPDATE ON nature_of_work FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241116155829_create_table_office.sql

```sql
CREATE TABLE office ( id INTEGER GENERATED BY DEFAULT AS IDENTITY NOT NULL PRIMARY KEY, unit_id INTEGER NOT NULL REFERENCES unit(id), code VARCHAR(50) NOT NULL UNIQUE, name VARCHAR(200) NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Create index for foreign key CREATE INDEX idx_office_unit_id ON office(unit_id); -- Add updated_at trigger CREATE TRIGGER set_updated_at BEFORE UPDATE ON office FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241116160732_create_table_program.sql

```sql
CREATE TABLE program ( id INTEGER GENERATED BY DEFAULT AS IDENTITY NOT NULL PRIMARY KEY, unit_id INTEGER NOT NULL REFERENCES unit(id), office_id INTEGER NOT NULL REFERENCES office(id), name TEXT NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Create indexes for foreign keys CREATE INDEX idx_program_unit_id ON program(unit_id); CREATE INDEX idx_program_office_id ON program(office_id); -- Add updated_at trigger CREATE TRIGGER set_updated_at BEFORE UPDATE ON program FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241116161506_create_table_position.sql

```sql
CREATE TABLE position ( id INTEGER GENERATED BY DEFAULT AS IDENTITY NOT NULL PRIMARY KEY, nature_of_work_id INTEGER NOT NULL REFERENCES nature_of_work(id), name VARCHAR(100) NOT NULL UNIQUE, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Create index for foreign key CREATE INDEX idx_position_nature_of_work_id ON position(nature_of_work_id); -- Add updated_at trigger CREATE TRIGGER set_updated_at BEFORE UPDATE ON position FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241116161733_create_table_employee_status.sql

```sql
-- create table CREATE TABLE employee_status ( id INTEGER GENERATED BY DEFAULT AS IDENTITY NOT NULL PRIMARY KEY, type VARCHAR(100) NOT NULL UNIQUE, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Add updated_at trigger CREATE TRIGGER set_updated_at BEFORE UPDATE ON employee_status FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241116162523_create_table_profile.sql

```sql
-- Create a table for public profiles create table profiles ( id uuid references auth.users on delete cascade not null primary key, updated_at timestamp with time zone default timezone('utc'::text, now()), employee_id varchar(50) unique, email varchar(255) unique, first_name text, middle_name text, last_name text, avatar_url text, unit_id integer references unit(id), nature_of_work_id integer references nature_of_work(id), office_id integer references office(id), program_id integer references program(id), position_id integer references position(id), employee_status_id integer references employee_status(id), created_at timestamp with time zone default timezone('utc'::text, now()) ); -- Set up Row Level Security (RLS) alter table profiles enable row level security; create policy "Public profiles are viewable by everyone." on profiles for select using (true); create policy "Users can insert their own profile." on profiles for insert with check ((select auth.uid()) = id); create policy "Users can update own profile." on profiles for update using ((select auth.uid()) = id); -- Create function to handle new user signup with Google OAuth data create function public.handle_new_user() returns trigger language plpgsql security definer set search_path = public as $$ begin insert into public.profiles ( id, email, first_name, last_name, avatar_url ) values ( new.id, new.email, coalesce( new.raw_user_meta_data->>'first_name', new.raw_user_meta_data->>'given_name', split_part(new.raw_user_meta_data->>'full_name', ' ', 1), 'Anonymous' ), coalesce( new.raw_user_meta_data->>'last_name', new.raw_user_meta_data->>'family_name', array_to_string( array_remove( string_to_array(new.raw_user_meta_data->>'full_name', ' '), split_part(new.raw_user_meta_data->>'full_name', ' ', 1) ), ' ' ), 'User' ), coalesce( new.raw_user_meta_data->>'avatar_url', new.raw_user_meta_data->>'picture', new.raw_user_meta_data->>'avatar', null ) ); return new; exception when others then raise log 'Error in handle_new_user: %', SQLERRM; return new; -- Still return the user even if profile creation fails end; $$; -- Create trigger for new user signup create trigger on_auth_user_created after insert on auth.users for each row execute procedure public.handle_new_user(); -- Set up Storage! insert into storage.buckets (id, name, public) values ('avatars', 'avatars',true); -- Set up access controls for storage. -- See https://supabase.com/docs/guides/storage#policy-examples for more details. create policy "Avatar images are publicly accessible." on storage.objects for select using (bucket_id = 'avatars'); create policy "Anyone can upload an avatar." on storage.objects for insert with check (bucket_id = 'avatars'); -- Allow users to upload their own avatar create policy "Users can update their own avatar" on storage.objects for update to authenticated using ( bucket_id = 'avatars' and auth.uid()::text = (storage.foldername(name))[1] ); -- Add updated_at trigger CREATE TRIGGER set_updated_at BEFORE UPDATE ON profiles FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241122141115_add_cascade_on_delete.sql

```sql
-- First, drop existing foreign key constraints ALTER TABLE office DROP CONSTRAINT office_unit_id_fkey; ALTER TABLE program DROP CONSTRAINT program_unit_id_fkey; ALTER TABLE program DROP CONSTRAINT program_office_id_fkey; ALTER TABLE position DROP CONSTRAINT position_nature_of_work_id_fkey; -- Then add them back with ON DELETE CASCADE ALTER TABLE office ADD CONSTRAINT office_unit_id_fkey FOREIGN KEY (unit_id) REFERENCES unit(id) ON DELETE CASCADE; ALTER TABLE program ADD CONSTRAINT program_unit_id_fkey FOREIGN KEY (unit_id) REFERENCES unit(id) ON DELETE CASCADE; ALTER TABLE program ADD CONSTRAINT program_office_id_fkey FOREIGN KEY (office_id) REFERENCES office(id) ON DELETE CASCADE; ALTER TABLE position ADD CONSTRAINT position_nature_of_work_id_fkey FOREIGN KEY (nature_of_work_id) REFERENCES nature_of_work(id) ON DELETE CASCADE;
```

# 20241122170218_add_realtime_tables.sql

```sql
alter publication supabase_realtime add table unit, nature_of_work, office, program, position, employee_status, profiles;
```

# 20241127102744_scope_type.sql

```sql
-- Create scope type CREATE TYPE scope_type AS ENUM ('all', 'office','program', 'unit');
```

# 20241127115411_create_roles_table.sql

```sql
-- Roles table CREATE TABLE roles ( id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, name VARCHAR(100) NOT NULL UNIQUE, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL );
```

# 20241127120413_create_permissions_table.sql

```sql
-- Permissions table CREATE TABLE permissions ( id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, name VARCHAR(100) NOT NULL UNIQUE, description TEXT, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL );
```

# 20241127121741_create_role_permissions_table.sql

```sql
-- Role permissions mapping with scope CREATE TABLE role_permissions ( id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, role_id INTEGER REFERENCES roles(id) ON DELETE CASCADE, permission_id INTEGER REFERENCES permissions(id) ON DELETE CASCADE, scope scope_type NOT NULL DEFAULT 'unit', created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, UNIQUE(role_id, permission_id) );
```

# 20241127121931_create_user_roles_table.sql

```sql
-- User roles mapping (one role per user) CREATE TABLE user_roles ( id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE, role_id INTEGER NOT NULL REFERENCES roles(id) ON DELETE CASCADE, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, UNIQUE(user_id) );
```

# 20241127123124_create_auth_jwt_function.sql

```sql
-- Grant necessary permissions GRANT USAGE ON SCHEMA auth TO postgres, authenticated, anon; GRANT SELECT ON TABLE user_roles TO supabase_auth_admin; GRANT SELECT ON TABLE roles TO supabase_auth_admin; GRANT EXECUTE ON FUNCTION auth.jwt() TO postgres, authenticated, anon; -- Create the JWT function CREATE OR REPLACE FUNCTION auth.jwt() RETURNS jsonb LANGUAGE plpgsql SECURITY DEFINER SET search_path = auth, public AS $$ DECLARE result jsonb; BEGIN SELECT jsonb_build_object( 'role', roles.name, 'role_id', roles.id ) INTO result FROM user_roles JOIN roles ON user_roles.role_id = roles.id WHERE user_roles.user_id = auth.uid(); RETURN COALESCE(result, '{}'::jsonb); END; $$;
```

# 20241127123317_create_permission_check_function.sql

```sql
CREATE OR REPLACE FUNCTION check_permission( required_permission VARCHAR, target_office_id INTEGER DEFAULT NULL, target_unit_id INTEGER DEFAULT NULL, target_program_id INTEGER DEFAULT NULL ) RETURNS BOOLEAN AS $$ DECLARE user_permission_scope scope_type; user_assigned_office_id INTEGER; user_assigned_unit_id INTEGER; user_assigned_program_id INTEGER; permission_exists BOOLEAN; BEGIN -- Get user's scope and IDs SELECT role_permission.scope, profile.office_id, profile.unit_id, profile.program_id, EXISTS ( SELECT 1 FROM role_permissions role_permission_check JOIN permissions permission ON permission.id = role_permission_check.permission_id WHERE role_permission_check.role_id = (auth.jwt()->>'role_id')::integer AND permission.name = required_permission ) INTO user_permission_scope, user_assigned_office_id, user_assigned_unit_id, user_assigned_program_id, permission_exists FROM profiles profile JOIN user_roles user_role ON profile.id = user_role.user_id JOIN role_permissions role_permission ON user_role.role_id = role_permission.role_id JOIN permissions permission ON role_permission.permission_id = permission.id WHERE profile.id = auth.uid() AND permission.name = required_permission; -- No permission found IF NOT permission_exists THEN RETURN FALSE; END IF; -- Check scope access from highest (all) to lowest (unit) RETURN CASE -- All level (highest scope) WHEN user_permission_scope = 'all' THEN TRUE -- Program level WHEN user_permission_scope = 'program' THEN target_program_id IS NULL OR target_program_id = user_assigned_program_id -- Office level WHEN user_permission_scope = 'office' THEN target_office_id IS NULL OR target_office_id = user_assigned_office_id -- Unit level (lowest scope) WHEN user_permission_scope = 'unit' THEN target_unit_id IS NULL OR target_unit_id = user_assigned_unit_id -- Default case ELSE FALSE END; END; $$ LANGUAGE plpgsql SECURITY DEFINER;
```

# 20241127152010_create_user_role_view.sql

```sql
CREATE VIEW user_role_view AS SELECT user_roles.user_id, roles.name as role_name, roles.id as role_id FROM user_roles JOIN roles ON user_roles.role_id = roles.id; CREATE OR REPLACE FUNCTION get_user_role() RETURNS TABLE ( role_name VARCHAR, role_id INTEGER ) LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$ BEGIN RETURN QUERY SELECT roles.name, roles.id FROM user_roles JOIN roles ON user_roles.role_id = roles.id WHERE user_roles.user_id = auth.uid(); END; $$; -- Grant execute permission GRANT EXECUTE ON FUNCTION get_user_role() TO authenticated;
```

# 20241128090943_system_admin_create_insert_function.sql

```sql
-- Create function to check if user is system admin CREATE OR REPLACE FUNCTION is_system_admin() RETURNS BOOLEAN LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$ DECLARE user_role_name VARCHAR; BEGIN -- Get the role name from the JWT SELECT (auth.jwt()->>'role')::VARCHAR INTO user_role_name; -- Check if user has system_admin role RETURN user_role_name = 'system_admin'; END; $$; -- Grant execute permission GRANT EXECUTE ON FUNCTION is_system_admin() TO authenticated;
```

# 20241128091037_RLS_for_unit.sql

```sql
-- Apply RLS policies to each table ALTER TABLE unit ENABLE ROW LEVEL SECURITY; CREATE POLICY "Enable read access for all users on unit" ON unit FOR SELECT TO authenticated USING (true); CREATE POLICY "Enable insert for system admin on unit" ON unit FOR INSERT TO authenticated WITH CHECK (is_system_admin()); CREATE POLICY "Enable update for system admin on unit" ON unit FOR UPDATE TO authenticated USING (is_system_admin()) WITH CHECK (is_system_admin()); CREATE POLICY "Enable delete for system admin on unit" ON unit FOR DELETE TO authenticated USING (is_system_admin());
```

# 20241128091124_RLS_for_office.sql

```sql
ALTER TABLE office ENABLE ROW LEVEL SECURITY; -- Create policies for office table CREATE POLICY "Enable read access for all users on office" ON office FOR SELECT TO authenticated USING (true); CREATE POLICY "Enable insert for system admin on office" ON office FOR INSERT TO authenticated WITH CHECK (is_system_admin()); CREATE POLICY "Enable update for system admin on office" ON office FOR UPDATE TO authenticated USING (is_system_admin()) WITH CHECK (is_system_admin()); CREATE POLICY "Enable delete for system admin on office" ON office FOR DELETE TO authenticated USING (is_system_admin());
```

# 20241128091158_RLS_for_program.sql

```sql
ALTER TABLE program ENABLE ROW LEVEL SECURITY; -- Create policies for program table CREATE POLICY "Enable read access for all users on program" ON program FOR SELECT TO authenticated USING (true); CREATE POLICY "Enable insert for system admin on program" ON program FOR INSERT TO authenticated WITH CHECK (is_system_admin()); CREATE POLICY "Enable update for system admin on program" ON program FOR UPDATE TO authenticated USING (is_system_admin()) WITH CHECK (is_system_admin()); CREATE POLICY "Enable delete for system admin on program" ON program FOR DELETE TO authenticated USING (is_system_admin());
```

# 20241128091248_RLS_for_nature_of_work.sql

```sql
ALTER TABLE nature_of_work ENABLE ROW LEVEL SECURITY; -- Create policies for nature_of_work table CREATE POLICY "Enable read access for all users on nature_of_work" ON nature_of_work FOR SELECT TO authenticated USING (true); CREATE POLICY "Enable insert for system admin on nature_of_work" ON nature_of_work FOR INSERT TO authenticated WITH CHECK (is_system_admin()); CREATE POLICY "Enable update for system admin on nature_of_work" ON nature_of_work FOR UPDATE TO authenticated USING (is_system_admin()) WITH CHECK (is_system_admin()); CREATE POLICY "Enable delete for system admin on nature_of_work" ON nature_of_work FOR DELETE TO authenticated USING (is_system_admin());
```

# 20241128091505_RLS_for_position.sql

```sql
ALTER TABLE position ENABLE ROW LEVEL SECURITY; -- Create policies for position table CREATE POLICY "Enable read access for all users on position" ON position FOR SELECT TO authenticated USING (true); CREATE POLICY "Enable insert for system admin on position" ON position FOR INSERT TO authenticated WITH CHECK (is_system_admin()); CREATE POLICY "Enable update for system admin on position" ON position FOR UPDATE TO authenticated USING (is_system_admin()) WITH CHECK (is_system_admin()); CREATE POLICY "Enable delete for system admin on position" ON position FOR DELETE TO authenticated USING (is_system_admin());
```

# 20241128091542_RLS_for_employee_status.sql

```sql
ALTER TABLE employee_status ENABLE ROW LEVEL SECURITY; CREATE POLICY "Enable read access for all users on employee_status" ON employee_status FOR SELECT TO authenticated USING (true); CREATE POLICY "Enable insert for system admin on employee_status" ON employee_status FOR INSERT TO authenticated WITH CHECK (is_system_admin()); CREATE POLICY "Enable update for system admin on employee_status" ON employee_status FOR UPDATE TO authenticated USING (is_system_admin()) WITH CHECK (is_system_admin()); CREATE POLICY "Enable delete for system admin on employee_status" ON employee_status FOR DELETE TO authenticated USING (is_system_admin());
```

# 20241204145404_create_ipcr_table.sql

```sql
-- Create status enum type CREATE TYPE ipcr_status AS ENUM ('draft', 'submitted', 'reviewing','revision', 'approved'); -- Create ipcr_teaching table with status CREATE TABLE ipcr ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), title VARCHAR(255) NOT NULL, status ipcr_status DEFAULT 'draft' NOT NULL, owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE, unit_id INTEGER REFERENCES unit(id) ON DELETE CASCADE, office_id INTEGER REFERENCES office(id) ON DELETE CASCADE, program_id INTEGER REFERENCES program(id) ON DELETE CASCADE, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); CREATE TRIGGER set_updated_at BEFORE UPDATE ON ipcr FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241204145806_create_core_function_table.sql

```sql
-- Create core_function table CREATE TABLE core_function ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), name TEXT NOT NULL, ipcr_id UUID REFERENCES ipcr(id) ON DELETE CASCADE NOT NULL, unit NUMERIC(4,2), reviewer_id UUID REFERENCES auth.users(id), position SMALLINT NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, UNIQUE(name, ipcr_id) ); -- Add index for better query performance when ordering by position CREATE INDEX idx_core_function_position ON core_function(position, ipcr_id); -- Trigger for updating the updated_at timestamp CREATE TRIGGER set_updated_at BEFORE UPDATE ON core_function FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241204145908_create_sub_core_function_table.sql

```sql
CREATE TABLE sub_core_function ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), core_function_id UUID REFERENCES core_function(id) ON DELETE CASCADE NOT NULL, name TEXT NOT NULL, position INTEGER NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, UNIQUE(core_function_id, name) ); -- Add an index on position and core_function_id for better performance when sorting CREATE INDEX idx_sub_core_function_position ON sub_core_function(core_function_id, position); CREATE TRIGGER set_updated_at BEFORE UPDATE ON sub_core_function FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241204150054_indicator_table.sql

```sql
-- Create status enum type CREATE TYPE indicator_status AS ENUM ('draft', 'submitted', 'reviewing', 'revision', 'approved'); CREATE TABLE indicator ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), status indicator_status DEFAULT 'draft' NOT NULL, indicator TEXT NOT NULL, indicator_date DATE, accomplishment TEXT, accomplishment_date DATE, quality_rating NUMERIC(3,2), efficiency_rating NUMERIC(3,2), timeliness_rating NUMERIC(3,2), average_rating NUMERIC(3,2), core_function_id UUID REFERENCES core_function(id) ON DELETE CASCADE, sub_core_function_id UUID REFERENCES sub_core_function(id) ON DELETE CASCADE, position INTEGER NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Add an index for better query performance when ordering by position CREATE INDEX idx__indicator_position ON indicator(position, core_function_id); CREATE TRIGGER set_updated_at BEFORE UPDATE ON indicator FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241211113611_create_support_function.sql

```sql
-- Create support_function table CREATE TABLE support_function ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), name TEXT NOT NULL, ipcr_id UUID REFERENCES ipcr(id) ON DELETE CASCADE NOT NULL, unit NUMERIC(4,2), reviewer_id UUID REFERENCES auth.users(id), position SMALLINT NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, UNIQUE(name, ipcr_id) ); -- Add index for better query performance when ordering by position CREATE INDEX idx_support_function_position ON support_function(position, ipcr_id); -- Trigger for updating the updated_at timestamp CREATE TRIGGER set_updated_at BEFORE UPDATE ON support_function FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241211113904_create_sub_support_function.sql

```sql
CREATE TABLE sub_support_function ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), support_function_id UUID REFERENCES support_function(id) ON DELETE CASCADE NOT NULL, name TEXT NOT NULL, position INTEGER NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, UNIQUE(support_function_id, name) ); -- Add an index on position and support_function_id for better performance when sorting CREATE INDEX idx_sub_support_function_position ON sub_support_function(support_function_id, position); CREATE TRIGGER set_updated_at BEFORE UPDATE ON sub_support_function FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241211114649_alter_indicator_add_support_functions.sql

```sql
ALTER TABLE indicator ADD COLUMN support_function_id UUID REFERENCES support_function(id) ON DELETE CASCADE, ADD COLUMN sub_support_function_id UUID REFERENCES sub_support_function(id) ON DELETE CASCADE;
```

# 20241212100049_create_other_function.sql

```sql
-- Create other_function table CREATE TABLE other_function ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), name TEXT NOT NULL, ipcr_id UUID REFERENCES ipcr(id) ON DELETE CASCADE NOT NULL, unit NUMERIC(4,2), reviewer_id UUID REFERENCES auth.users(id), position SMALLINT NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, UNIQUE(name, ipcr_id) ); -- Add index for better query performance when ordering by position CREATE INDEX idx_other_function_position ON other_function(position, ipcr_id); -- Trigger for updating the updated_at timestamp CREATE TRIGGER set_updated_at BEFORE UPDATE ON other_function FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241212100058_create_sub_other_function.sql

```sql
CREATE TABLE sub_other_function ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), other_function_id UUID REFERENCES other_function(id) ON DELETE CASCADE NOT NULL, name TEXT NOT NULL, position INTEGER NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, UNIQUE(other_function_id, name) ); -- Add an index on position and other_function_id for better performance when sorting CREATE INDEX idx_sub_other_function_position ON sub_other_function(other_function_id, position); CREATE TRIGGER set_updated_at BEFORE UPDATE ON sub_other_function FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241212101127_create_subother_function.sql

```sql

```

# 20241212103421_alter_indicator_add_othe_function.sql

```sql
ALTER TABLE indicator ADD COLUMN other_function_id UUID REFERENCES other_function(id) ON DELETE CASCADE, ADD COLUMN sub_other_function_id UUID REFERENCES sub_other_function(id) ON DELETE CASCADE;
```

# 20241215053527_make_evidence_bucket.sql

```sql
-- Create a new storage bucket for evidence files insert into storage.buckets (id, name, public) values ('indicator_evidence', 'indicator_evidence', false); -- CREATE POLICY "User can read their own evidence files" -- ON storage.objects FOR SELECT USING ( -- bucket_id = 'indicator_evidence' -- AND auth.uid()::text = (storage.foldername(name))[1] -- ); CREATE POLICY "User can upload their own evidence files" ON storage.objects FOR INSERT WITH CHECK ( bucket_id = 'indicator_evidence' AND auth.uid()::text = (storage.foldername(name))[1] ); -- CREATE POLICY "User can delete their own evidence files" -- ON storage.objects FOR DELETE USING ( -- bucket_id = 'indicator_evidence' -- AND auth.uid()::text = (storage.foldername(name))[1] -- );
```

# 20241215080245_make_indicator_evidence_table.sql

```sql
-- Create evidence table CREATE TABLE indicator_evidence ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), indicator_id UUID REFERENCES indicator(id) ON DELETE CASCADE NOT NULL, file_path TEXT NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Create index for better query performance CREATE INDEX idx_indicator_evidence_indicator_id ON indicator_evidence(indicator_id);
```

# 20241215125239_create_ipcr_checker_complete.sql

```sql
-- First create the type DROP TYPE IF EXISTS validation_result CASCADE; CREATE TYPE validation_result AS ( is_valid boolean, validation_message text ); CREATE OR REPLACE FUNCTION validate_ipcr(p_ipcr_id UUID) RETURNS validation_result LANGUAGE plpgsql AS $$ DECLARE result validation_result; invalid_function RECORD; has_core boolean; has_support boolean; has_other boolean; BEGIN -- Check if IPCR has required function types SELECT EXISTS(SELECT 1 FROM core_function WHERE ipcr_id = p_ipcr_id) as has_core, EXISTS(SELECT 1 FROM support_function WHERE ipcr_id = p_ipcr_id) as has_support, EXISTS(SELECT 1 FROM other_function WHERE ipcr_id = p_ipcr_id) as has_other INTO has_core, has_support, has_other; -- Check for missing function types IF NOT has_core THEN result := (false, 'Core Function: Missing Core Functions'); RETURN result; END IF; IF NOT has_support THEN result := (false, 'Support Function: Missing Support Functions'); RETURN result; END IF; IF NOT has_other THEN result := (false, 'Other Function: Missing Other Functions'); RETURN result; END IF; -- Check core functions SELECT cf.id, cf.name, 'Core' as function_type, CASE WHEN cf.unit IS NULL AND cf.reviewer_id IS NULL THEN 'Missing Fields: Unit and Reviewer' WHEN cf.unit IS NULL THEN 'Missing Field: Unit' WHEN cf.reviewer_id IS NULL THEN 'Missing Field: Reviewer' WHEN EXISTS ( SELECT 1 FROM indicator i WHERE i.core_function_id = cf.id AND i.sub_core_function_id IS NULL AND ( i.indicator IS NULL OR i.indicator_date IS NULL ) ) OR EXISTS ( SELECT 1 FROM sub_core_function scf JOIN indicator i ON i.sub_core_function_id = scf.id WHERE scf.core_function_id = cf.id AND ( i.indicator IS NULL OR i.indicator_date IS NULL ) ) THEN 'Missing Fields: Indicator Description or Target Date' WHEN NOT EXISTS ( SELECT 1 FROM indicator i WHERE i.core_function_id = cf.id AND i.sub_core_function_id IS NULL UNION SELECT 1 FROM sub_core_function scf JOIN indicator i ON i.sub_core_function_id = scf.id WHERE scf.core_function_id = cf.id ) THEN 'No Indicators Found' END as missing_field INTO invalid_function FROM core_function cf WHERE cf.ipcr_id = p_ipcr_id AND ( cf.unit IS NULL OR cf.reviewer_id IS NULL OR EXISTS ( SELECT 1 FROM indicator i WHERE i.core_function_id = cf.id AND i.sub_core_function_id IS NULL AND ( i.indicator IS NULL OR i.indicator_date IS NULL ) ) OR EXISTS ( SELECT 1 FROM sub_core_function scf JOIN indicator i ON i.sub_core_function_id = scf.id WHERE scf.core_function_id = cf.id AND ( i.indicator IS NULL OR i.indicator_date IS NULL ) ) OR NOT EXISTS ( SELECT 1 FROM indicator i WHERE i.core_function_id = cf.id AND i.sub_core_function_id IS NULL UNION SELECT 1 FROM sub_core_function scf JOIN indicator i ON i.sub_core_function_id = scf.id WHERE scf.core_function_id = cf.id ) ) LIMIT 1; IF FOUND THEN result := (false, format('%s Function "%s": %s', invalid_function.function_type, invalid_function.name, invalid_function.missing_field)); RETURN result; END IF; -- Check support functions SELECT sf.id, sf.name, 'Support' as function_type, CASE WHEN sf.unit IS NULL AND sf.reviewer_id IS NULL THEN 'Missing Fields: Unit and Reviewer' WHEN sf.unit IS NULL THEN 'Missing Field: Unit' WHEN sf.reviewer_id IS NULL THEN 'Missing Field: Reviewer' WHEN EXISTS ( SELECT 1 FROM indicator i WHERE i.support_function_id = sf.id AND i.sub_support_function_id IS NULL AND ( i.indicator IS NULL OR i.indicator_date IS NULL ) ) OR EXISTS ( SELECT 1 FROM sub_support_function ssf JOIN indicator i ON i.sub_support_function_id = ssf.id WHERE ssf.support_function_id = sf.id AND ( i.indicator IS NULL OR i.indicator_date IS NULL ) ) THEN 'Missing Fields: Indicator Description or Target Date' WHEN NOT EXISTS ( SELECT 1 FROM indicator i WHERE i.support_function_id = sf.id AND i.sub_support_function_id IS NULL UNION SELECT 1 FROM sub_support_function ssf JOIN indicator i ON i.sub_support_function_id = ssf.id WHERE ssf.support_function_id = sf.id ) THEN 'No Indicators Found' END as missing_field INTO invalid_function FROM support_function sf WHERE sf.ipcr_id = p_ipcr_id AND ( sf.unit IS NULL OR sf.reviewer_id IS NULL OR EXISTS ( SELECT 1 FROM indicator i WHERE i.support_function_id = sf.id AND i.sub_support_function_id IS NULL AND ( i.indicator IS NULL OR i.indicator_date IS NULL ) ) OR EXISTS ( SELECT 1 FROM sub_support_function ssf JOIN indicator i ON i.sub_support_function_id = ssf.id WHERE ssf.support_function_id = sf.id AND ( i.indicator IS NULL OR i.indicator_date IS NULL ) ) OR NOT EXISTS ( SELECT 1 FROM indicator i WHERE i.support_function_id = sf.id AND i.sub_support_function_id IS NULL UNION SELECT 1 FROM sub_support_function ssf JOIN indicator i ON i.sub_support_function_id = ssf.id WHERE ssf.support_function_id = sf.id ) ) LIMIT 1; IF FOUND THEN result := (false, format('%s Function "%s": %s', invalid_function.function_type, invalid_function.name, invalid_function.missing_field)); RETURN result; END IF; -- Check other functions SELECT of.id, of.name, 'Other' as function_type, CASE WHEN of.unit IS NULL AND of.reviewer_id IS NULL THEN 'Missing Fields: Unit and Reviewer' WHEN of.unit IS NULL THEN 'Missing Field: Unit' WHEN of.reviewer_id IS NULL THEN 'Missing Field: Reviewer' WHEN EXISTS ( SELECT 1 FROM indicator i WHERE i.other_function_id = of.id AND i.sub_other_function_id IS NULL AND ( i.indicator IS NULL OR i.indicator_date IS NULL ) ) OR EXISTS ( SELECT 1 FROM sub_other_function sof JOIN indicator i ON i.sub_other_function_id = sof.id WHERE sof.other_function_id = of.id AND ( i.indicator IS NULL OR i.indicator_date IS NULL ) ) THEN 'Missing Fields: Indicator Description or Target Date' WHEN NOT EXISTS ( SELECT 1 FROM indicator i WHERE i.other_function_id = of.id AND i.sub_other_function_id IS NULL UNION SELECT 1 FROM sub_other_function sof JOIN indicator i ON i.sub_other_function_id = sof.id WHERE sof.other_function_id = of.id ) THEN 'No Indicators Found' END as missing_field INTO invalid_function FROM other_function of WHERE of.ipcr_id = p_ipcr_id AND ( of.unit IS NULL OR of.reviewer_id IS NULL OR EXISTS ( SELECT 1 FROM indicator i WHERE i.other_function_id = of.id AND i.sub_other_function_id IS NULL AND ( i.indicator IS NULL OR i.indicator_date IS NULL ) ) OR EXISTS ( SELECT 1 FROM sub_other_function sof JOIN indicator i ON i.sub_other_function_id = sof.id WHERE sof.other_function_id = of.id AND ( i.indicator IS NULL OR i.indicator_date IS NULL ) ) OR NOT EXISTS ( SELECT 1 FROM indicator i WHERE i.other_function_id = of.id AND i.sub_other_function_id IS NULL UNION SELECT 1 FROM sub_other_function sof JOIN indicator i ON i.sub_other_function_id = sof.id WHERE sof.other_function_id = of.id ) ) LIMIT 1; IF FOUND THEN result := (false, format('%s Function "%s": %s', invalid_function.function_type, invalid_function.name, invalid_function.missing_field)); RETURN result; END IF; -- If we get here, everything is valid result := (true, 'IPCR is complete and valid'); RETURN result; END; $$;
```

# 20241216163511_create_table_operational_plan.sql

```sql
-- Create operational_plan table CREATE TABLE operational_plan ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), creator_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL, unit_id INTEGER REFERENCES unit(id) ON DELETE CASCADE NOT NULL, office_id INTEGER REFERENCES office(id) ON DELETE CASCADE NOT NULL, program_id INTEGER REFERENCES program(id) ON DELETE CASCADE NOT NULL, title TEXT NOT NULL, implimenting_unit TEXT NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); CREATE INDEX idx_operational_plan_unit_id ON operational_plan(unit_id); CREATE INDEX idx_operational_plan_office_id ON operational_plan(office_id); CREATE INDEX idx_operational_plan_program_id ON operational_plan(program_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON operational_plan FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241218095055_create_op_header_table.sql

```sql
-- Create op_header table CREATE TABLE op_header ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), operational_plan_id UUID REFERENCES operational_plan(id) ON DELETE CASCADE NOT NULL, position INTEGER NOT NULL, title TEXT NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Add indexes for better query performance CREATE INDEX idx_op_header_operational_plan_id ON op_header(operational_plan_id); CREATE INDEX idx_op_header_position ON op_header(position, operational_plan_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON op_header FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241218095410_create_op_program_project_table.sql

```sql
-- Create op_program_project table CREATE TABLE op_program_project ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), op_header_id UUID REFERENCES op_header(id) ON DELETE CASCADE NOT NULL, description TEXT NOT NULL, position INTEGER NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Add indexes for better query performance CREATE INDEX idx_op_program_project_header_id ON op_program_project(op_header_id); CREATE INDEX idx_op_program_project_position ON op_program_project(position, op_header_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON op_program_project FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

# 20241218095833_create_op_objective_table.sql

```sql
-- Create op_objectives table CREATE TABLE op_objectives ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), op_program_project_id UUID REFERENCES op_program_project(id) ON DELETE CASCADE NOT NULL, objective TEXT NOT NULL, activity TEXT NOT NULL, indicator TEXT NOT NULL, former_state VARCHAR(255) NOT NULL, desired_state VARCHAR(255) NOT NULL, q1 BOOLEAN DEFAULT false NOT NULL, q2 BOOLEAN DEFAULT false NOT NULL, q3 BOOLEAN DEFAULT false NOT NULL, q4 BOOLEAN DEFAULT false NOT NULL, item TEXT, qty TEXT, unit TEXT, unit_cost TEXT, amount TEXT, fund_source TEXT, entity_responsible TEXT NOT NULL, position INTEGER NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL ); -- Add indexes for better query performance CREATE INDEX idx_op_objectives_program_project_id ON op_objectives(op_program_project_id); CREATE INDEX idx_op_objectives_position ON op_objectives(position, op_program_project_id); -- Add trigger for updating timestamps CREATE TRIGGER set_updated_at BEFORE UPDATE ON op_objectives FOR EACH ROW EXECUTE FUNCTION fn_set_updated_at();
```

